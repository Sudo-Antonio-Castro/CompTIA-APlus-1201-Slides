<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CompTIA A+ 1201 — System Devices</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 900px;
    margin: auto;
    padding: 20px;
  }

  #slide {
    border: 2px solid #ccc;
    padding: 40px;
    margin-bottom: 16px;
    min-height: 200px;
    font-size: 1.2em;
    text-align: left;
    background: #f9f9f9;
  }

  /* Carousel (auto-hides if no images) */
  #carouselWrap {
    border: 2px solid #ccc;
    background: #fff;
    padding: 16px;
    margin-bottom: 20px;
  }

  .carousel {
    display: grid;
    gap: 10px;
    align-items: center;
  }

  .carouselTop {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }

  .carouselImgFrame {
    border: 1px solid #ddd;
    background: #fafafa;
    padding: 10px;
    display: grid;
    place-items: center;
    min-height: 260px;
  }

  #carouselImg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  .carouselBtns {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  .dots {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
  }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 999px;
    border: 1px solid #666;
    background: transparent;
    cursor: pointer;
    padding: 0;
  }

  .dot.active {
    background: #4a90e2;
    border-color: #4a90e2;
  }

  .buttons {
    margin-top: 10px;
    display: flex;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
  }

  .buttons .left, .buttons .right {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  button, a.homeLink {
    padding: 10px 14px;
    cursor: pointer;
    text-decoration: none;
    color: inherit;
    border: 1px solid #bbb;
    background: #fff;
    display: inline-block;
  }

  button:hover, a.homeLink:hover {
    background: #f1f1f1;
  }

  #counter {
    font-weight: bold;
  }
</style>
</head>

<body>
<h1>CompTIA A+ 1201 — Module 3: Installing System Devices</h1>

<div id="slide"></div>

<!-- Carousel container (auto-hides if no images) -->
<div id="carouselWrap" style="display:none;">
  <div class="carousel">
    <div class="carouselTop">
      <div class="carouselBtns">
        <button id="prevImgBtn" onclick="prevImage()">◀ Image</button>
        <button id="nextImgBtn" onclick="nextImage()">Image ▶</button>
        <span id="imgCounter" style="font-weight:bold;"></span>
      </div>
      <div class="dots" id="dots"></div>
    </div>

    <div class="carouselImgFrame">
      <img id="carouselImg" alt="Slide image" />
    </div>
  </div>
</div>

<div class="buttons">
  <div class="left">
    <button onclick="goHome()">Return Home</button>
    <button onclick="goToFirstSlide()">First Slide</button>
    <button onclick="prevSlide()">Previous</button>
    <button onclick="nextSlide()">Next</button>
    <span id="counter"></span>
  </div>

  <div class="right">
    <button id="enableAudioBtn" onclick="enableAudio()">Enable audio</button>
    <button id="replayBtn" onclick="replayAudio()" disabled>Replay audio</button>
  </div>
</div>

<audio id="slideAudio" preload="auto"></audio>

<script>
  // Place this file at: System-Devices/index.html
  // Recommended audio naming (in System-Devices/audio/):
  //   01.mp3, 02.mp3, 03.mp3, ... (matching slide numbers)
  // This script also supports: 1.mp3, 1.wav, 01.wav, 1.m4a, etc.
  // If your audio is stored at repo root /audio instead, it will also try ../audio/.

  const pad2 = (n) => String(n).padStart(2, "0");

  const slides = [{"content":"<h2>Module 3: Installing System Devices</h2><p>CompTIA A+ 1201</p>","images":[]},{"content":"<h2>Lessons</h2><ul><li>Power Supplies and Cooling</li><li>Storage Devices</li><li>System Memory</li><li>CPUs</li></ul>","images":[]},{"content":"<h2>Power Supply Units</h2><ul><li>A PSU’s main job is to convert wall power (AC) into the low-voltage DC power the PC actually uses.</li><li>Physical compatibility matters: PSU size/form factor must fit the case, and the PSU must support the motherboard’s required main power connector style.</li><li>Input voltage matters: some PSUs auto-switch for different regions, while others may require a selector switch—plugging the wrong way can damage components.</li><li>PSUs provide multiple voltage rails (commonly 3.3V, 5V, and 12V DC) and supply power to both the motherboard and attached devices.</li><li>Good PSU choice isn’t just “it turns on”—it’s about stable power delivery under load, especially for systems with higher performance parts.</li></ul>","images":[]},{"content":"<h2>Wattage Rating</h2><ul><li>Wattage is the maximum power the PSU can supply; you match it to the system’s total demand (CPU, GPU, drives, fans, etc.).</li><li>Undersizing the PSU can cause random shutdowns, reboot loops, instability, and even component damage over time.</li><li>Beyond total watts, you also care about how the wattage is distributed across rails—modern systems lean heavily on the +12V rail.</li><li>Efficiency affects heat and power draw: a more efficient PSU wastes less energy as heat, helping reliability and cooling.</li><li>“80 PLUS” efficiency tiers (like Bronze/Silver/Gold) reflect how efficiently the PSU converts AC to DC at different loads.</li></ul>","images":[]},{"content":"<h2>Power Supply Connectors</h2><ul><li>The PSU uses different connectors to power different components—motherboard, CPU, drives, and PCIe add-on cards.</li><li>The main motherboard connector is commonly the 24-pin (P1) connector.</li><li>Drives commonly use SATA power; older/peripherals may use Molex.</li><li>CPUs and GPUs often require dedicated 4/6/8-pin (or higher) power connectors to handle higher current draw.</li><li>Matching the right connector type prevents boot failures and avoids dangerous “almost fits” situations.</li></ul>","images":[]},{"content":"<h2>20 + 4 Pin Motherboard Adapter</h2><ul><li>Older motherboards used a 20-pin ATX main power connector; most modern systems use 24-pin.</li><li>An adapter (or a “20+4” design) allows compatibility between a legacy PSU and a newer motherboard in some cases.</li><li>The additional pins help provide extra power capacity and stability for modern boards.</li><li>Always verify the PSU can support the board’s power needs—an adapter doesn’t magically increase available wattage.</li></ul>","images":[]},{"content":"<h2>Modular Power Supplies</h2><ul><li>Modular PSUs have detachable cables, so you only install the cables you actually need.</li><li>Benefits: less cable clutter, easier routing, and better airflow inside the case (which helps cooling).</li><li>It can also improve serviceability (simpler swaps, cleaner troubleshooting).</li><li>The performance isn’t automatically better than non-modular—modularity is mainly about build quality and airflow/cable management.</li></ul>","images":[]},{"content":"<h2>Redundant Power Supplies</h2><ul><li>Redundant PSUs are common in servers/data centers where uptime is critical.</li><li>Two PSUs can provide failover—if one PSU dies, the other keeps the system running.</li><li>Many redundant PSU setups are hot-swappable (replace without shutting down), which is huge for business continuity.</li><li>This is much less common in standard desktops because it adds cost and complexity.</li></ul>","images":[]},{"content":"<h2>Fan Cooling Systems</h2><ul><li>Heat is a normal byproduct of electricity moving through components; too much heat causes throttling, instability, and hardware damage.</li><li>A fan cooling system depends on airflow design: intake brings cool air in, exhaust removes hot air out.</li><li>Good airflow is about a clean “path” through the case—not just stuffing in more fans.</li><li>Dust buildup blocks airflow and insulation-like dust layers trap heat, so cleaning is part of maintenance.</li></ul>","images":[]},{"content":"<h2>Heat Sinks and Thermal Paste</h2><ul><li>A heat sink pulls heat away by using high surface area (fins) to transfer heat to the air.</li><li>Thermal paste (or a thermal pad) fills microscopic gaps between the CPU and heat sink so heat transfers efficiently.</li><li>Without proper paste/contact, you get hot spots, poor cooling, and potential CPU shutdowns under load.</li><li>Heat sinks can be passive or paired with fans; CPUs typically use an active setup for reliable cooling.</li></ul>","images":[]},{"content":"<h2>Fans</h2><ul><li>Fans may be mounted as front/side intake and rear/top exhaust to create a consistent airflow pattern.</li><li>CPU fans often mount directly to the heat sink; case fans manage overall chassis temperature.</li><li>Balanced airflow matters: too much exhaust without intake can pull dust in through gaps; too much intake without exhaust traps heat.</li><li>Many systems use fan control (BIOS/UEFI or OS utilities) to adjust speeds based on temperature.</li></ul>","images":[]},{"content":"<h2>Liquid Cooling</h2><ul><li>Liquid cooling moves heat via a loop rather than relying only on air at the CPU.</li><li>Core parts of an open-loop system include tubing/loop + pump, water block, and a radiator + fans.</li><li>Liquid cooling can be quieter and better at handling sustained high loads, but it adds complexity.</li><li>Open-loop systems require periodic maintenance (checking fluid, cleaning, potentially draining/refilling).</li><li>Closed-loop/AIO coolers reduce maintenance and installation complexity compared to open-loop setups.</li></ul>","images":[]},{"content":"<h2>Lesson 3.2 Storage Devices</h2>","images":[]},{"content":"<h2>Mass Storage Devices</h2><ul><li>“Mass storage” refers to non-volatile storage (data remains when power is off).</li><li>Storage choices are usually evaluated by reliability, performance, and use case (office PC vs gaming vs server vs backups).</li><li>Drives may be internal (mounted in bays) or external/removable (connected by USB/other interfaces).</li><li>Form factors and bay sizes matter (common internal sizes include 2.5\" and 3.5\", and 5.25\" bays for optical).</li></ul>","images":[]},{"content":"<h2>Solid State Drives (SSDs)</h2><ul><li>SSDs store data on flash memory with no moving parts, making them fast and resistant to mechanical shock.</li><li>They typically provide faster boot times, application launches, and general responsiveness than HDDs.</li><li>Flash memory has limited write endurance; controllers use techniques like wear leveling to spread writes and extend lifespan.</li><li>SSD interfaces include:</li><li>SATA SSDs (common, easy upgrade path, but bandwidth-limited compared to PCIe)</li><li>PCIe/NVMe SSDs (very high performance, often in M.2 form factor)</li><li>Other enterprise/high-performance options like SAS depending on environment</li><li>Cost per GB is usually higher than HDDs, so SSD/HDD combos are common (SSD for OS/apps, HDD for bulk storage).</li></ul>","images":[]},{"content":"<h2>Hard Disk Drives (HDDs)</h2><ul><li>HDDs use spinning platters and read/write heads—mechanical parts that can wear out or fail from shock.</li><li>They offer large capacities at low cost per GB, making them great for bulk storage and backups.</li><li>HDD performance depends on RPM (5400 vs 7200 vs 10k), cache, and interface.</li><li>Because they’re mechanical, HDDs are slower than SSDs for random access and boot/app loads.</li></ul>","images":[]},{"content":"<h2>Hybrid Drives (SSHD)</h2><ul><li>SSHDs combine a traditional HDD with a small amount of flash storage used as a cache.</li><li>The drive “learns” frequently accessed data and keeps it in flash to improve performance.</li><li>They are faster than HDDs but generally slower than full SSDs.</li><li>They can be a cost-effective middle ground when you want more speed without SSD-level cost for large capacities.</li></ul>","images":[]},{"content":"<h2>Redundant Array of Independent Disks (RAID)</h2><ul><li>RAID combines multiple drives into one logical unit to improve performance, fault tolerance, or both.</li><li>Different RAID “levels” trade off speed vs redundancy vs capacity.</li><li>RAID is not a backup—RAID protects against drive failure, not accidental deletion, malware, or corruption.</li></ul>","images":[]},{"content":"<h2>Raid 0 and Raid 1</h2><div style=\"display:flex; gap:24px; align-items:flex-start;\"><div style=\"flex:1; min-width:0;\"><ul><li>RAID 0 uses striping (splitting data across drives) to improve performance.</li><li>Requires at least two drives.</li><li>Major downside: no redundancy—if one drive fails, the entire array fails.</li><li>Best fit: performance-focused situations where data loss is acceptable (scratch disk, non-critical workloads).</li></ul></div><div style=\"flex:1; min-width:0;\"><ul><li>RAID 1 uses mirroring (same data written to two drives).</li><li>Requires at least two drives.</li><li>Benefit: redundancy—if one drive fails, the other still has the data.</li><li>Downside: usable capacity is effectively 50% (because data is duplicated).</li></ul></div></div>","images":[]},{"content":"<h2>RAID 5 and RAID 10</h2><div style=\"display:flex; gap:24px; align-items:flex-start;\"><div style=\"flex:1; min-width:0;\"><ul><li>RAID 5 uses striping with distributed parity (error recovery info spread across drives).</li><li>Requires at least three drives.</li><li>Can survive one drive failure without losing data.</li><li>Good balance of capacity and fault tolerance, but writes can be slower due to parity calculations.</li></ul></div><div style=\"flex:1; min-width:0;\"><ul><li>RAID 10 combines RAID 1 and RAID 0 (often described as a stripe of mirrors).</li><li>Requires at least four drives (and usually an even number).</li><li>Excellent performance and redundancy, but capacity is reduced due to mirroring.</li><li>Common in high-performance environments where uptime matters (databases, heavy workloads).</li></ul></div></div>","images":[]},{"content":"<h2>RAID 6</h2><ul><li>RAID 6 is like RAID 5 but stores two sets of parity, allowing survival of two simultaneous drive failures.</li><li>Requires at least four drives.</li><li>More fault tolerant than RAID 5, but has higher write overhead due to extra parity calculations.</li><li>Useful for large arrays where the chance of a second failure during rebuild is a real concern.</li></ul>","images":[]},{"content":"<h2>Removable Storage Drives</h2><ul><li>Drive enclosures can turn internal drives (HDD/SSD) into external USB storage.</li><li>Great for backups, data transfer, or repurposing old drives.</li><li>External drives can be HDD or SSD; SSD external drives are faster and more shock-resistant.</li><li>Memory cards (SD, microSD) are common in mobile devices and cameras, and also by speed ratings (important for cameras/video).</li></ul>","images":[]},{"content":"<h2>Optical Drives</h2><ul><li>Optical drives read/write removable discs (CD/DVD/Blu-ray).</li><li>Less common now, but still used for legacy media, software installs, and archival storage.</li><li>Speed and capacity vary: CD (~700MB), DVD (~4.7GB single-layer), Blu-ray (25GB+).</li><li>They often use SATA internally or USB externally.</li></ul>","images":[]},{"content":"<h2>Flash Drives and Memory Cards</h2><ul><li>USB flash drives are portable, solid-state, and commonly used for quick file transfer and boot media.</li><li>Memory cards (SD, microSD) are common in phones, cameras, and small devices.</li><li>Performance and reliability vary widely—watch for counterfeit/low-quality media.</li><li>They’re convenient but easy to lose; encryption is a good idea for sensitive data.</li></ul>","images":[]},{"content":"<h2>Drive Interfaces (SATA, NVMe, SAS)</h2><ul><li>SATA is common for consumer HDDs/SSDs; easy upgrades and wide compatibility.</li><li>NVMe uses PCIe lanes and delivers much higher performance, often in M.2 form factor.</li><li>SAS is typically enterprise-focused, supporting high reliability and dual-pathing in servers.</li><li>Interface choice affects speed, compatibility, and intended environment (desktop vs server).</li></ul>","images":[]},{"content":"<h2>Lesson 3.3 System Memory</h2>","images":[]},{"content":"<h2>System Memory (RAM) Basics</h2><ul><li>RAM is volatile memory: it stores data temporarily while the system is powered on.</li><li>More RAM improves multitasking and helps systems handle larger workloads without relying on slower storage.</li><li>Key specs: capacity (GB), speed (MHz/MT/s), latency (CAS), and form factor (DIMM/SO-DIMM).</li><li>Compatibility depends on the motherboard and CPU platform (DDR generation, supported speeds, channels).</li></ul>","images":[]},{"content":"<h2>DDR Generations</h2><ul><li>DDR generations are not interchangeable (DDR3 vs DDR4 vs DDR5 use different slots/keys).</li><li>Newer DDR typically offers higher speeds and better efficiency.</li><li>Motherboard and CPU must both support the DDR type you install.</li><li>Always check the motherboard QVL/support list for best compatibility.</li></ul>","images":[]},{"content":"<h2>Dual-Channel vs Single-Channel</h2><ul><li>Dual-channel memory uses matched sticks to increase memory bandwidth.</li><li>Installing RAM in the correct paired slots (per motherboard manual) enables dual-channel mode.</li><li>Single-channel works but can reduce performance, especially for integrated graphics systems.</li><li>Matched kits are recommended for stability and best performance.</li></ul>","images":[]},{"content":"<h2>ECC vs Non-ECC</h2><ul><li>ECC (Error-Correcting Code) RAM can detect and correct certain memory errors, improving reliability.</li><li>Common in servers/workstations where stability and uptime matter.</li><li>Requires motherboard and CPU support; not typical for standard consumer desktops.</li><li>Non-ECC is most common for everyday PCs and gaming systems.</li></ul>","images":[]},{"content":"<h2>Lesson 3.4 CPUs</h2>","images":[]},{"content":"<h2>CPU Basics</h2><ul><li>The CPU executes instructions and is a primary driver of system performance.</li><li>Key factors: cores/threads, clock speed, cache, architecture, and power/thermal design (TDP).</li><li>Cooling and proper thermal paste are critical for stability and preventing throttling.</li><li>CPU choice must match motherboard socket and chipset support.</li></ul>","images":[]},{"content":"<h2>CPU Cores and Threads</h2><ul><li>More cores help with parallel workloads (multitasking, content creation, virtualization).</li><li>Threads (via SMT/Hyper-Threading) allow a core to handle multiple instruction streams more efficiently.</li><li>Single-core performance still matters for many everyday tasks and some games.</li><li>Real-world performance depends on workload type, not just core count.</li></ul>","images":[]},{"content":"<h2>CPU Sockets</h2><ul><li>CPU socket type must match the motherboard (Intel and AMD use different families and generations).</li><li>Even within a socket family, chipset/BIOS support can determine which CPUs are compatible.</li><li>Upgrading a CPU may require a BIOS/UEFI update first.</li><li>Never force a CPU into a socket—pin damage is expensive and often irreversible.</li></ul>","images":[]},{"content":"<h2>CPU Cooling and Installation</h2><ul><li>Proper installation includes aligning the CPU correctly, securing it, and applying appropriate thermal compound.</li><li>Attach the heat sink/fan or AIO cooler securely and connect the fan header (CPU_FAN).</li><li>Verify temperatures in BIOS/UEFI and under load to ensure cooling is adequate.</li><li>Improper cooling can cause crashes, throttling, and shortened component lifespan.</li></ul>","images":[]},{"content":"<h2>CPU Types and Motherboard Compatibility</h2><ul><li>Compatibility is primarily about socket, chipset, and BIOS support.</li><li>Feature support like PCIe version, memory type (DDR4/DDR5), and integrated graphics/AI support can matter too.</li><li>Consider core count, thermal requirements, and intended workload when selecting a CPU.</li></ul>","images":[]}];

  // Slide state
  let index = 0;

  // Carousel state (for current slide)
  let imgIndex = 0;

  // Audio state
  let audioEnabled = false;

  // ---- Audio resolution (fixes "only slide 3 plays" when filenames/extensions don't match) ----
  const AUDIO_FOLDERS = ["audio", "../audio"]; // tries System-Devices/audio first, then repo-root audio
  const AUDIO_BASES = (n) => [pad2(n), String(n), `slide-${pad2(n)}`, `slide-${n}`];
  const AUDIO_EXTS = ["mp3", "m4a", "wav", "ogg"];

  const audioSrcCache = new Map(); // slideNumber (1-based) -> resolved src string

  async function urlExists(url) {
    try {
      // Try HEAD first (fast)
      const head = await fetch(url, { method: "HEAD", cache: "no-store" });
      if (head.ok) return true;

      // Some servers don't like HEAD; try a tiny ranged GET
      const get = await fetch(url, {
        method: "GET",
        headers: { "Range": "bytes=0-0" },
        cache: "no-store"
      });
      return get.ok;
    } catch (e) {
      return false;
    }
  }

  async function resolveAudioSrc(slideNumber) {
    if (audioSrcCache.has(slideNumber)) return audioSrcCache.get(slideNumber);

    const candidates = [];
    for (const folder of AUDIO_FOLDERS) {
      for (const base of AUDIO_BASES(slideNumber)) {
        for (const ext of AUDIO_EXTS) {
          candidates.push(`${folder}/${base}.${ext}`);
          candidates.push(`${folder}/${base}.${ext.toUpperCase()}`);
        }
      }
    }

    for (const c of candidates) {
      if (await urlExists(c)) {
        audioSrcCache.set(slideNumber, c);
        return c;
      }
    }

    console.log(`[audio] No audio file found for slide ${slideNumber}. Tried:`, candidates);
    return null; // don't cache null so you can add files later without refreshing JS
  }

  async function playCurrentAudio() {
    if (!audioEnabled) return;

    const audio = document.getElementById("slideAudio");
    audio.pause();
    audio.currentTime = 0;

    // Optional per-slide override:
    // slides[i].audio = "audio/customname.mp3"  OR  slides[i].audio = false to disable audio for that slide
    let src = slides[index].audio;

    if (src === false) return;

    if (typeof src !== "string" || !src.trim()) {
      src = await resolveAudioSrc(index + 1);
    }

    if (!src) return;

    // Only re-set src if changed (helps some browsers)
    const abs = new URL(src, window.location.href).href;
    if (audio.src !== abs) {
      audio.src = src;
      audio.load();
    }

    try {
      await audio.play();
    } catch (err) {
      console.log("[audio] Play blocked or missing file:", err);
    }
  }

  function enableAudio() {
    audioEnabled = true;
    document.getElementById("replayBtn").disabled = false;
    playCurrentAudio();
  }

  function replayAudio() {
    playCurrentAudio();
  }

  // ---- Carousel ----
  function renderCarousel() {
    const wrap = document.getElementById("carouselWrap");
    const imgEl = document.getElementById("carouselImg");
    const dotsEl = document.getElementById("dots");
    const imgCounter = document.getElementById("imgCounter");
    const prevBtn = document.getElementById("prevImgBtn");
    const nextBtn = document.getElementById("nextImgBtn");

    const filenames = (slides[index].images || []).filter(Boolean);

    // Hide carousel if 0 images
    if (filenames.length === 0) {
      wrap.style.display = "none";
      return;
    }

    wrap.style.display = "block";

    // Clamp imgIndex
    if (imgIndex < 0) imgIndex = 0;
    if (imgIndex > filenames.length - 1) imgIndex = filenames.length - 1;

    imgEl.src = `images/${filenames[imgIndex]}`;
    imgCounter.textContent = `Image ${imgIndex + 1} / ${filenames.length}`;

    prevBtn.disabled = (filenames.length <= 1) || (imgIndex === 0);
    nextBtn.disabled = (filenames.length <= 1) || (imgIndex === filenames.length - 1);

    // Build dots
    dotsEl.innerHTML = "";
    if (filenames.length > 1) {
      filenames.forEach((_, i) => {
        const b = document.createElement("button");
        b.className = "dot" + (i === imgIndex ? " active" : "");
        b.title = `Go to image ${i + 1}`;
        b.onclick = () => { imgIndex = i; renderCarousel(); };
        dotsEl.appendChild(b);
      });
    }
  }

  function nextImage() {
    const filenames = (slides[index].images || []).filter(Boolean);
    if (imgIndex < filenames.length - 1) {
      imgIndex++;
      renderCarousel();
    }
  }

  function prevImage() {
    if (imgIndex > 0) {
      imgIndex--;
      renderCarousel();
    }
  }

  // ---- Slides ----
  function showSlide() {
    document.getElementById("slide").innerHTML = slides[index].content;
    document.getElementById("counter").textContent = `Slide ${index + 1} / ${slides.length}`;

    // Reset carousel on slide change
    imgIndex = 0;
    renderCarousel();

    // Play slide audio (if enabled)
    playCurrentAudio();
  }

  function nextSlide() {
    if (index < slides.length - 1) index++;
    showSlide();
  }

  function prevSlide() {
    if (index > 0) index--;
    showSlide();
  }

  function goToFirstSlide() {
    index = 0;
    showSlide();
  }

  // "Return Home" goes back to repo root
  function goHome() {
    window.location.href = "../";
  }

  // Keyboard:
  // Left/Right = slide nav
  // A/D = image nav
  // Home = first slide
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowRight") nextSlide();
    if (e.key === "ArrowLeft") prevSlide();
    if (e.key.toLowerCase() === "d") nextImage();
    if (e.key.toLowerCase() === "a") prevImage();
    if (e.key === "Home") goToFirstSlide();
  });

  showSlide();
</script>

</body>
</html>
