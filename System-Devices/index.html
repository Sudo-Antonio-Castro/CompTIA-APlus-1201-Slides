<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CompTIA A+ 1201 — System Devices</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 900px;
    margin: auto;
    padding: 20px;
  }

  #slide {
    border: 2px solid #ccc;
    padding: 40px;
    margin-bottom: 16px;
    min-height: 200px;
    font-size: 1.2em;
    text-align: left;
    background: #f9f9f9;
  }

  /* Carousel */
  #carouselWrap {
    border: 2px solid #ccc;
    background: #fff;
    padding: 16px;
    margin-bottom: 20px;
  }

  .carousel {
    display: grid;
    gap: 10px;
    align-items: center;
  }

  .carouselTop {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }

  .carouselImgFrame {
    border: 1px solid #ddd;
    background: #fafafa;
    padding: 10px;
    display: grid;
    place-items: center;
    min-height: 260px;
  }

  #carouselImg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  .carouselBtns {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  .dots {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
  }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 999px;
    border: 1px solid #666;
    background: transparent;
    cursor: pointer;
    padding: 0;
  }

  .dot.active {
    background: #4a90e2;
    border-color: #4a90e2;
  }

  .buttons {
    margin-top: 10px;
    display: flex;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
  }

  .buttons .left, .buttons .right {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  button {
    padding: 10px 14px;
    cursor: pointer;
    text-decoration: none;
    color: inherit;
    border: 1px solid #bbb;
    background: #fff;
    display: inline-block;
  }

  button:hover {
    background: #f1f1f1;
  }

  #counter {
    font-weight: bold;
  }
</style>
</head>

<body>
<h1>CompTIA A+ 1201 — Module 3: Installing System Devices</h1>

<div id="slide"></div>

<!-- Carousel container (auto-hides if no images) -->
<div id="carouselWrap" style="display:none;">
  <div class="carousel">
    <div class="carouselTop">
      <div class="carouselBtns">
        <button id="prevImgBtn" onclick="prevImage()">◀ Image</button>
        <button id="nextImgBtn" onclick="nextImage()">Image ▶</button>
        <span id="imgCounter" style="font-weight:bold;"></span>
      </div>
      <div class="dots" id="dots"></div>
    </div>

    <div class="carouselImgFrame">
      <img id="carouselImg" alt="Slide image" />
    </div>
  </div>
</div>

<div class="buttons">
  <div class="left">
    <button onclick="goHome()">Return Home</button>
    <button onclick="goToFirstSlide()">First Slide</button>
    <button onclick="prevSlide()">Previous</button>
    <button onclick="nextSlide()">Next</button>
    <span id="counter"></span>
  </div>

  <div class="right">
    <button id="enableAudioBtn" onclick="enableAudio()">Enable audio</button>
    <button id="replayBtn" onclick="replayAudio()" disabled>Replay audio</button>
  </div>
</div>

<audio id="slideAudio" preload="auto"></audio>

<script>
  // Put this file at: System-Devices/index.html
  // Audio files at: System-Devices/audio/<filename>
  // Image files at: System-Devices/images/<filename>
  // Add image filenames per slide in the "images" array to enable the carousel.

  const pad2 = (n) => String(n).padStart(2, "0");

  // IMPORTANT:
  // - Images are placeholders (empty arrays). Add filenames like: ["01-1.png","01-2.png"] if you want.
  // - Audio is OPTIONAL per slide. Only slides with `audio: "xx.mp3"` will play audio.
  //   Currently: only Slide 3 has audio enabled (set to "03.mp3"). Change as you like.

  const slides = [
    {
      content: "<h2>Module 3: Installing System Devices</h2><p>CompTIA A+ 1201</p>",
      images: [],
      audio: null
    },
    {
      content: "<h2>Lessons</h2><ul><li>Power Supplies and Cooling</li><li>Storage Devices</li><li>System Memory</li><li>CPUs</li></ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Power Supply Units</h2>" +
        "<ul>" +
        "<li>A PSU’s main job is to convert wall power (AC) into the low-voltage DC power the PC actually uses.</li>" +
        "<li>Physical compatibility matters: PSU size/form factor must fit the case, and the PSU must support the motherboard’s required main power connector style.</li>" +
        "<li>Input voltage matters: some PSUs auto-switch for different regions, while others may require a selector switch—plugging the wrong way can damage components.</li>" +
        "<li>PSUs provide multiple voltage rails (commonly 3.3V, 5V, and 12V DC) and supply power to both the motherboard and attached devices.</li>" +
        "<li>Good PSU choice isn’t just “it turns on”—it’s about stable power delivery under load, especially for systems with higher performance parts.</li>" +
        "</ul>",
      images: [],
      audio: "03.mp3"   // ✅ only slide 3 plays audio (edit/remove if you want different behavior)
    },
    {
      content:
        "<h2>Wattage Rating</h2>" +
        "<ul>" +
        "<li>Wattage is the maximum power the PSU can supply; you match it to the system’s total demand (CPU, GPU, drives, fans, etc.).</li>" +
        "<li>Undersizing the PSU can cause random shutdowns, reboot loops, instability, and even component damage over time.</li>" +
        "<li>Beyond total watts, you also care about how the wattage is distributed across rails—modern systems lean heavily on the +12V rail.</li>" +
        "<li>Efficiency affects heat and power draw: a more efficient PSU wastes less energy as heat, helping reliability and cooling.</li>" +
        "<li>“80 PLUS” efficiency tiers (like Bronze/Silver/Gold) reflect how efficiently the PSU converts AC to DC at different loads.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Power Supply Connectors</h2>" +
        "<ul>" +
        "<li>The PSU uses different connectors to power different components—motherboard, CPU, drives, and PCIe add-on cards.</li>" +
        "<li>The main motherboard connector is commonly the 24-pin (P1) connector.</li>" +
        "<li>Drives commonly use SATA power; older/peripherals may use Molex.</li>" +
        "<li>CPUs and GPUs often require dedicated 4/6/8-pin (or higher) power connectors to handle higher current draw.</li>" +
        "<li>Matching the right connector type prevents boot failures and avoids dangerous “almost fits” situations.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>20 + 4 Pin Motherboard Adapter</h2>" +
        "<ul>" +
        "<li>Older motherboards used a 20-pin ATX main power connector; most modern systems use 24-pin.</li>" +
        "<li>An adapter (or a “20+4” design) allows compatibility between a legacy PSU and a newer motherboard in some cases.</li>" +
        "<li>The additional pins help provide extra power capacity and stability for modern boards.</li>" +
        "<li>Always verify the PSU can support the board’s power needs—an adapter doesn’t magically increase available wattage.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Modular Power Supplies</h2>" +
        "<ul>" +
        "<li>Modular PSUs have detachable cables, so you only install the cables you actually need.</li>" +
        "<li>Benefits: less cable clutter, easier routing, and better airflow inside the case (which helps cooling).</li>" +
        "<li>It can also improve serviceability (simpler swaps, cleaner troubleshooting).</li>" +
        "<li>The performance isn’t automatically better than non-modular—modularity is mainly about build quality and airflow/cable management.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Redundant Power Supplies</h2>" +
        "<ul>" +
        "<li>Redundant PSUs are common in servers/data centers where uptime is critical.</li>" +
        "<li>Two PSUs can provide failover—if one PSU dies, the other keeps the system running.</li>" +
        "<li>Many redundant PSU setups are hot-swappable (replace without shutting down), which is huge for business continuity.</li>" +
        "<li>This is much less common in standard desktops because it adds cost and complexity.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Fan Cooling Systems</h2>" +
        "<ul>" +
        "<li>Heat is a normal byproduct of electricity moving through components; too much heat causes throttling, instability, and hardware damage.</li>" +
        "<li>A fan cooling system depends on airflow design: intake brings cool air in, exhaust removes hot air out.</li>" +
        "<li>Good airflow is about a clean “path” through the case—not just stuffing in more fans.</li>" +
        "<li>Dust buildup blocks airflow and insulation-like dust layers trap heat, so cleaning is part of maintenance.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Heat Sinks and Thermal Paste</h2>" +
        "<ul>" +
        "<li>A heat sink pulls heat away by using high surface area (fins) to transfer heat to the air.</li>" +
        "<li>Thermal paste (or a thermal pad) fills microscopic gaps between the CPU and heat sink so heat transfers efficiently.</li>" +
        "<li>Without proper paste/contact, you get hot spots, poor cooling, and potential CPU shutdowns under load.</li>" +
        "<li>Heat sinks can be passive or paired with fans; CPUs typically use an active setup for reliable cooling.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Fans</h2>" +
        "<ul>" +
        "<li>Fans may be mounted as front/side intake and rear/top exhaust to create a consistent airflow pattern.</li>" +
        "<li>CPU fans often mount directly to the heat sink; case fans manage overall chassis temperature.</li>" +
        "<li>Balanced airflow matters: too much exhaust without intake can pull dust in through gaps; too much intake without exhaust traps heat.</li>" +
        "<li>Many systems use fan control (BIOS/UEFI or OS utilities) to adjust speeds based on temperature.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Liquid Cooling</h2>" +
        "<ul>" +
        "<li>Liquid cooling moves heat via a loop rather than relying only on air at the CPU.</li>" +
        "<li>Core parts of an open-loop system include tubing/loop + pump, water block, and a radiator + fans.</li>" +
        "<li>Liquid cooling can be quieter and better at handling sustained high loads, but it adds complexity.</li>" +
        "<li>Open-loop systems require periodic maintenance (checking fluid, cleaning, potentially draining/refilling).</li>" +
        "<li>Closed-loop/AIO coolers reduce maintenance and installation complexity compared to open-loop setups.</li>" +
        "</ul>",
      images: [],
      audio: null
    },

    { content: "<h2>Lesson 3.2 Storage Devices</h2>", images: [], audio: null },

    {
      content:
        "<h2>Mass Storage Devices</h2>" +
        "<ul>" +
        "<li>“Mass storage” refers to non-volatile storage (data remains when power is off).</li>" +
        "<li>Storage choices are usually evaluated by reliability, performance, and use case (office PC vs gaming vs server vs backups).</li>" +
        "<li>Drives may be internal (mounted in bays) or external/removable (connected by USB/other interfaces).</li>" +
        "<li>Form factors and bay sizes matter (common internal sizes include 2.5&quot; and 3.5&quot;, and 5.25&quot; bays for optical).</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Solid State Drives (SSDs)</h2>" +
        "<ul>" +
        "<li>SSDs store data on flash memory with no moving parts, making them fast and resistant to mechanical shock.</li>" +
        "<li>They typically provide faster boot times, application launches, and general responsiveness than HDDs.</li>" +
        "<li>Flash memory has limited write endurance; controllers use techniques like wear leveling to spread writes and extend lifespan.</li>" +
        "<li>SSD interfaces include:" +
          "<ul>" +
          "<li>SATA SSDs (common, easy upgrade path, but bandwidth-limited compared to PCIe)</li>" +
          "<li>PCIe/NVMe SSDs (very high performance, often in M.2 form factor)</li>" +
          "<li>Other enterprise/high-performance options like SAS depending on environment</li>" +
          "</ul>" +
        "</li>" +
        "<li>Cost per GB is usually higher than HDDs, so SSD/HDD combos are common (SSD for OS/apps, HDD for bulk storage).</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Hard Disk Drives (HDDs)</h2>" +
        "<ul>" +
        "<li>HDDs store data on spinning magnetic platters using moving read/write heads.</li>" +
        "<li>They’re typically cheaper per GB than SSDs, making them useful for large storage (archives, media libraries, backups).</li>" +
        "<li>Performance depends heavily on RPM (e.g., common consumer speeds like 5400/7200, higher in some performance/enterprise drives).</li>" +
        "<li>They commonly connect via SATA, and usually come in 3.5&quot; (desktop) or 2.5&quot; (laptop/small form factor).</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Redundant Array of Independent Disks (RAID)</h2>" +
        "<ul>" +
        "<li>RAID combines multiple drives into one logical unit to improve performance, fault tolerance, or both.</li>" +
        "<li>Different RAID “levels” trade off speed, usable capacity, and resilience to drive failure.</li>" +
        "<li>RAID is not a replacement for backups—some RAID levels improve uptime, but they don’t protect you from accidental deletion, malware, or corruption.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>RAID 0 and RAID 1</h2>" +
        "<div>" +
          "<h3>RAID 0 (Striping)</h3>" +
          "<ul>" +
          "<li>Uses striping (splitting data across drives) to improve performance.</li>" +
          "<li>Requires at least two drives.</li>" +
          "<li>No redundancy — if one drive fails, the entire array fails.</li>" +
          "<li>Best fit: performance-focused situations where data loss is acceptable (scratch disk, non-critical workloads).</li>" +
          "</ul>" +
        "</div>" +
        "<hr>" +
        "<div>" +
          "<h3>RAID 1 (Mirroring)</h3>" +
          "<ul>" +
          "<li>Uses mirroring (same data written to two drives).</li>" +
          "<li>Requires at least two drives.</li>" +
          "<li>Strong redundancy — if one drive fails, data is still available on the other drive.</li>" +
          "<li>Tradeoff: usable capacity is effectively 50% (because data is duplicated).</li>" +
          "</ul>" +
        "</div>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>RAID 5 and RAID 10</h2>" +
        "<div>" +
          "<h3>RAID 5 (Striping with Distributed Parity)</h3>" +
          "<ul>" +
          "<li>Requires at least three drives.</li>" +
          "<li>Can survive one drive failure while keeping data accessible.</li>" +
          "<li>Writes are slower than RAID 0/1 because parity must be calculated and written.</li>" +
          "</ul>" +
        "</div>" +
        "<hr>" +
        "<div>" +
          "<h3>RAID 10 (Stripe of Mirrors)</h3>" +
          "<ul>" +
          "<li>Combines RAID 1 and RAID 0 (often described as a stripe of mirrors).</li>" +
          "<li>Requires at least four drives (and usually an even number).</li>" +
          "<li>Excellent performance and strong fault tolerance — one drive in each mirrored pair can fail without losing the array.</li>" +
          "<li>Common fit: high-performance environments where uptime matters (databases, heavy workloads).</li>" +
          "</ul>" +
        "</div>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>RAID 6</h2>" +
        "<ul>" +
        "<li>Like RAID 5 but stores two sets of parity, allowing survival of two simultaneous drive failures.</li>" +
        "<li>Requires at least four drives.</li>" +
        "<li>Tradeoffs: more overhead (less usable capacity) and slower writes than RAID 5 due to extra parity operations.</li>" +
        "<li>Common fit: larger arrays where a second failure during rebuild is a real concern.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Removable Storage Drives</h2>" +
        "<ul>" +
        "<li>Drive enclosures can turn internal HDDs/SSDs into portable storage with interfaces like USB, Thunderbolt, or eSATA.</li>" +
        "<li>Network Attached Storage (NAS) provides shared storage over the network and may support multiple disks (often using RAID).</li>" +
        "<li>Flash drives and memory cards are lightweight portable options, often used for quick transfer rather than long-term archival.</li>" +
        "<li>SD card families differ by capacity (e.g., SD/SDHC/SDXC) and also by speed ratings (important for cameras/video).</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Optical Drives</h2>" +
        "<ul>" +
        "<li>Optical media uses lasers to read/write data on discs like CD, DVD, and Blu-ray.</li>" +
        "<li>Discs vary by type: recordable vs rewritable, and some formats support multisession writing.</li>" +
        "<li>Typical capacities scale upward from CD (hundreds of MB) to DVD (multiple GB) to Blu-ray (tens of GB per layer).</li>" +
        "<li>Drives may be internal (mounted in a bay) or external (USB/other connection), and compatibility depends on both drive and disc format.</li>" +
        "</ul>",
      images: [],
      audio: null
    },

    { content: "<h2>Lesson 3.3 System Memory</h2>", images: [], audio: null },

    {
      content:
        "<h2>System RAM and Virtual Memory</h2>" +
        "<ul>" +
        "<li>RAM is fast working memory used for active programs; it’s volatile (clears when power is off).</li>" +
        "<li>When RAM is insufficient, systems use virtual memory (paging/swapping to storage) to keep running—slower than real RAM, but better than crashing.</li>" +
        "<li>Memory addressing concepts matter:</li>" +
        "<li><strong>Data pathway</strong> influences how much data moves per clock cycle.</li>" +
        "<li><strong>Address pathway</strong> influences how many memory locations can be accessed.</li>" +
        "<li>32-bit vs 64-bit addressing impacts how much memory can be utilized and how large the address space can be.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>RAM Types</h2>" +
        "<ul>" +
        "<li>Core RAM families include DRAM/SDRAM and DDR generations (DDR3/DDR4/DDR5), each improving speed and capacity over time.</li>" +
        "<li>“DDR” (Double Data Rate) improves throughput by transferring data more efficiently per clock cycle compared to earlier designs.</li>" +
        "<li>RAM performance is described using metrics like data rate (MT/s), bandwidth/transfer rate, and timings.</li>" +
        "<li>CAS latency is one timing value; lower latency can help performance, but consider it alongside RAM speed.</li>" +
        "<li>DDR generations are not interchangeable—each has different electrical and physical design constraints.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Memory Modules</h2>" +
        "<ul>" +
        "<li>RAM chips are packaged into modules:</li>" +
        "<li><strong>DIMMs</strong> are common in desktops.</li>" +
        "<li><strong>SODIMMs</strong> are common in laptops and compact devices.</li>" +
        "<li>Modules are keyed (notches) so the wrong DDR generation won’t fit the slot correctly.</li>" +
        "<li>Proper installation includes seating firmly, using the correct slots, and following ESD-safe handling practices.</li>" +
        "<li>Mixing RAM speeds/types usually causes downclocking to the slowest common settings—or failure to boot if incompatible.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>Multi Channel System Memory</h2>" +
        "<ul>" +
        "<li><strong>Single-channel</strong> uses one 64-bit data path; <strong>dual-channel</strong> uses two 64-bit paths (increasing bandwidth).</li>" +
        "<li>Dual-channel depends on correct slot population (motherboards often color-code paired slots).</li>" +
        "<li>Best results come from matching modules (same capacity, speed, timings).</li>" +
        "<li>Some systems support “flex mode,” where part of memory runs dual-channel and the remainder runs single-channel when capacities don’t match.</li>" +
        "<li>Higher-end platforms may support triple-channel or quad-channel, requiring CPU support and specific population rules.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>ECC RAM</h2>" +
        "<ul>" +
        "<li>ECC (Error-Correcting Code) RAM can detect and correct certain memory errors, improving stability.</li>" +
        "<li>Most common in servers/workstations where uptime and data integrity matter.</li>" +
        "<li>ECC requires compatibility across the CPU, motherboard, and memory type—ECC/non-ECC mixing is typically not supported.</li>" +
        "<li>Some ECC implementations use registered/buffered designs for stability with large memory configurations (common in enterprise environments).</li>" +
        "</ul>",
      images: [],
      audio: null
    },

    { content: "<h2>Lesson 3.4 CPUs</h2>", images: [], audio: null },

    {
      content:
        "<h2>CPU Architecture</h2>" +
        "<ul>" +
        "<li>The CPU processes instructions in a cycle commonly described as fetch → decode → execute → write-back.</li>" +
        "<li>Knowing this cycle helps when troubleshooting performance issues (e.g., bottlenecks from memory access vs compute).</li>" +
        "<li>Modern systems rely heavily on CPU caches and efficient instruction handling to keep execution pipelines full.</li>" +
        "<li>CPU architecture affects instruction set, compatibility, and performance characteristics.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>x86 CPU Architecture</h2>" +
        "<ul>" +
        "<li>x86 is traditionally associated with a 32-bit instruction set and broad compatibility across PCs.</li>" +
        "<li>Major x86 PC CPU manufacturers include Intel and AMD.</li>" +
        "<li>Key CPU components include the ALU (Arithmetic Logic Unit) and cache memory layers (L1/L2/L3) that reduce slow trips to RAM.</li>" +
        "<li>The instruction set style impacts complexity and how work is scheduled and optimized by the CPU.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>x64 CPU Architecture</h2>" +
        "<ul>" +
        "<li>x64 expands the architecture to handle 64-bit instructions and larger memory addressing.</li>" +
        "<li>Supports modern OS/app needs, including higher memory capacity and improved performance for many workloads.</li>" +
        "<li>Most modern CPUs and operating systems are x64; many x64 systems can still run 32-bit software (depending on OS support).</li>" +
        "<li>x64 is effectively the mainstream standard for modern desktops and laptops today.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>ARM CPU Architecture</h2>" +
        "<ul>" +
        "<li>ARM is widely used in mobile and embedded systems and commonly comes as a system-on-chip (SoC) with integrated controllers.</li>" +
        "<li>ARM systems often require OS/app builds compiled specifically for ARM instruction sets.</li>" +
        "<li>Many ARM implementations prioritize low power usage and heat efficiency, making them ideal for battery-powered devices.</li>" +
        "<li>Physical design often differs from desktop CPUs (frequently soldered to boards in thin devices).</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>CPU Features</h2>" +
        "<ul>" +
        "<li><strong>Multithreading/SMT</strong> allows one physical core to handle multiple threads more efficiently in supported workloads.</li>" +
        "<li><strong>Multicore</strong> CPUs improve parallel processing by distributing work across multiple physical cores.</li>" +
        "<li><strong>Symmetric multiprocessing</strong> supports multiple CPUs in a system (more common in servers/high-end workstations).</li>" +
        "<li><strong>Virtualization support</strong> enables running VMs more efficiently by assisting hypervisors at the hardware level.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>CPU Socket Types</h2>" +
        "<ul>" +
        "<li>Socket type must match between CPU and motherboard, and many sockets use ZIF (Zero Insertion Force) mechanisms for safer installation.</li>" +
        "<li><strong>PGA</strong> typically has pins on the CPU (commonly associated with certain AMD desktop lines).</li>" +
        "<li><strong>LGA</strong> typically has pins in the socket (commonly associated with Intel desktop sockets).</li>" +
        "<li>Socket families matter because they determine electrical layout, mechanical fit, and platform support.</li>" +
        "</ul>",
      images: [],
      audio: null
    },
    {
      content:
        "<h2>CPU Types and Motherboard Compatibility</h2>" +
        "<ul>" +
        "<li>Compatibility is driven by more than just socket fit—chipset support and BIOS/UEFI support can matter too.</li>" +
        "<li>Consider core count, thermal design/power requirements, and intended use (office desktop vs workstation vs server).</li>" +
        "<li>Matching CPU capability to workload prevents overspending while still meeting performance needs.</li>" +
        "<li>Proper installation and configuration improves performance and stability and reduces failure risk later.</li>" +
        "</ul>",
      images: [],
      audio: null
    }
  ];

  // Slide state
  let index = 0;

  // Carousel state (for current slide)
  let imgIndex = 0;

  // Audio state
  let audioEnabled = false;

  function audioPathForCurrentSlide() {
    const file = slides[index].audio;
    return file ? `audio/${file}` : null;
  }

  function stopAudio() {
    const audio = document.getElementById("slideAudio");
    audio.pause();
    audio.currentTime = 0;
  }

  async function playCurrentAudio() {
    const replayBtn = document.getElementById("replayBtn");
    if (!audioEnabled) {
      replayBtn.disabled = true;
      return;
    }

    const path = audioPathForCurrentSlide();
    if (!path) {
      replayBtn.disabled = true;
      return;
    }

    replayBtn.disabled = false;

    const audio = document.getElementById("slideAudio");
    audio.src = path;
    audio.currentTime = 0;

    try {
      await audio.play();
    } catch (err) {
      console.log("Audio play blocked or missing file:", err);
    }
  }

  function enableAudio() {
    audioEnabled = true;
    playCurrentAudio(); // only plays if current slide has audio
  }

  function replayAudio() {
    playCurrentAudio();
  }

  function renderCarousel() {
    const wrap = document.getElementById("carouselWrap");
    const imgEl = document.getElementById("carouselImg");
    const dotsEl = document.getElementById("dots");
    const imgCounter = document.getElementById("imgCounter");
    const prevBtn = document.getElementById("prevImgBtn");
    const nextBtn = document.getElementById("nextImgBtn");

    const filenames = (slides[index].images || []).filter(Boolean);

    // Hide carousel if 0 images
    if (filenames.length === 0) {
      wrap.style.display = "none";
      return;
    }

    wrap.style.display = "block";

    // Clamp imgIndex
    if (imgIndex < 0) imgIndex = 0;
    if (imgIndex > filenames.length - 1) imgIndex = filenames.length - 1;

    imgEl.src = `images/${filenames[imgIndex]}`;
    imgCounter.textContent = `Image ${imgIndex + 1} / ${filenames.length}`;

    prevBtn.disabled = (filenames.length <= 1) || (imgIndex === 0);
    nextBtn.disabled = (filenames.length <= 1) || (imgIndex === filenames.length - 1);

    // Build dots
    dotsEl.innerHTML = "";
    if (filenames.length > 1) {
      filenames.forEach((_, i) => {
        const b = document.createElement("button");
        b.className = "dot" + (i === imgIndex ? " active" : "");
        b.title = `Go to image ${i + 1}`;
        b.onclick = () => { imgIndex = i; renderCarousel(); };
        dotsEl.appendChild(b);
      });
    }
  }

  function nextImage() {
    const filenames = (slides[index].images || []).filter(Boolean);
    if (imgIndex < filenames.length - 1) {
      imgIndex++;
      renderCarousel();
    }
  }

  function prevImage() {
    if (imgIndex > 0) {
      imgIndex--;
      renderCarousel();
    }
  }

  function showSlide() {
    // stop any currently playing audio before switching slides
    stopAudio();

    document.getElementById("slide").innerHTML = slides[index].content;
    document.getElementById("counter").textContent = `Slide ${index + 1} / ${slides.length}`;

    // Reset carousel on slide change
    imgIndex = 0;
    renderCarousel();

    // Play slide audio (if enabled and slide has audio)
    playCurrentAudio();
  }

  function nextSlide() {
    if (index < slides.length - 1) index++;
    showSlide();
  }

  function prevSlide() {
    if (index > 0) index--;
    showSlide();
  }

  function goToFirstSlide() {
    index = 0;
    showSlide();
  }

  function goHome() {
    // Go back to repo root from System-Devices/
    window.location.href = "../";
  }

  // Keyboard:
  // Left/Right = slide nav
  // A/D = image nav
  // Home = first slide
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowRight") nextSlide();
    if (e.key === "ArrowLeft") prevSlide();
    if (e.key.toLowerCase() === "d") nextImage();
    if (e.key.toLowerCase() === "a") prevImage();
    if (e.key === "Home") goToFirstSlide();
  });

  showSlide();
</script>

</body>
</html>
