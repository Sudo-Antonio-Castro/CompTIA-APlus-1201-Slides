<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CompTIA A+ 1201 — System Devices</title>
  <meta name="description" content="CompTIA A+ 1201 Slides — Module 3: Installing System Devices" />

  <style>
    /* ======================= */
    /* KB Black/White Template */
    /* ======================= */

    :root{
      --bg: #ffffff;
      --panel: #ffffff;
      --text: #0b0b0f;
      --muted: #5b5b66;
      --border: #e6e6ee;
      --shadow: 0 6px 30px rgba(0,0,0,.08);
      --accent: #111111;
      --accent-2: #2b2b2b;
      --chip:#f2f2f7;
      --link:#111111;
      --focus: 0 0 0 3px rgba(0,0,0,.18);
      --radius: 14px;
      --radius-sm: 10px;
      --max: 1200px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }

    [data-theme="dark"]{
      --bg: #0b0b0f;
      --panel: #101014;
      --text: #f6f6fb;
      --muted: #b5b5c2;
      --border: #262633;
      --shadow: 0 10px 40px rgba(0,0,0,.40);
      --accent: #ffffff;
      --accent-2: #e7e7ef;
      --chip:#17171e;
      --link:#f6f6fb;
      --focus: 0 0 0 3px rgba(255,255,255,.18);
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family: var(--font);
      color: var(--text);
      background: var(--bg);
      line-height: 1.55;
    }
    a{ color:var(--link); text-decoration: none; }
    a:hover{ text-decoration: underline; }
    :focus-visible{ outline:none; box-shadow: var(--focus); border-radius: 8px; }

    /* Layout */
    .wrap{ max-width: var(--max); margin: 0 auto; padding: 18px; }

    header{
      position: sticky;
      top:0;
      z-index: 30;
      background: color-mix(in oklab, var(--bg) 88%, transparent);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
    }
    .topbar{
      display:flex;
      align-items:center;
      gap:12px;
      justify-content: space-between;
      padding: 14px 18px;
      max-width: var(--max);
      margin:0 auto;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 240px;
    }
    .logo{
      width:34px;height:34px;border-radius: 10px;
      background: var(--accent);
      box-shadow: var(--shadow);
      display:grid; place-items:center;
      flex: 0 0 auto;
    }
    .logo svg{ width:18px; height:18px; fill: var(--bg); }
    [data-theme="dark"] .logo svg{ fill: #0b0b0f; }

    .brand h1{
      font-size: 14px;
      margin:0;
      letter-spacing: .08em;
      text-transform: uppercase;
      opacity:.9;
    }
    .subtitle{
      font-size:12px;
      color: var(--muted);
      margin-top:2px;
    }

    .controls{
      display:flex; align-items:center; gap:10px;
      justify-content: flex-end;
    }

    .btn{
      border:1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: none;
      user-select:none;
      font-family: var(--font);
    }
    .btn:hover{ border-color: color-mix(in oklab, var(--border) 70%, var(--accent)); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn svg{ width:16px; height:16px; fill: var(--text); opacity:.85; }

    .panel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .panel .hd{
      padding: 14px 16px 12px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .panel .hd strong{
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .panel .bd{ padding: 16px; }

    .titleRow{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .titleRow h2{
      font-size: 22px;
      margin: 0;
      letter-spacing: -0.02em;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: var(--chip);
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .chip b{ color: var(--text); font-weight:600; }

    /* Slide box (content area) */
    #slide{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      padding: 22px;
      min-height: 220px;
    }
    #slide h2{ margin: 0 0 10px; font-size: 22px; letter-spacing: -0.01em; }
    #slide h3{ margin: 14px 0 8px; font-size: 16px; }
    #slide p{ margin: 10px 0; color: color-mix(in oklab, var(--text) 92%, var(--muted)); }
    #slide ul, #slide ol{ margin: 10px 0 10px 18px; color: color-mix(in oklab, var(--text) 92%, var(--muted)); }
    #slide hr{ border: none; height:1px; background: var(--border); margin: 16px 0; }

    /* Carousel */
    #carouselWrap{
      margin-top: 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      padding: 14px;
    }
    .carousel{
      display:grid;
      gap: 10px;
    }
    .carouselTop{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap:10px;
      flex-wrap: wrap;
    }
    .carouselBtns{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .carouselImgFrame{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: color-mix(in oklab, var(--chip) 55%, transparent);
      padding: 10px;
      min-height: 260px;
      display:grid;
      place-items:center;
      overflow:hidden;
    }
    #carouselImg{
      max-width: 100%;
      height: auto;
      display:block;
      border-radius: var(--radius-sm);
    }

    /* IMPORTANT: avoid collision with KB template's ".dot" usage */
    .cDots{
      display:flex;
      gap:6px;
      flex-wrap: wrap;
      align-items:center;
    }
    .cDot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid color-mix(in oklab, var(--border) 65%, var(--accent));
      background: transparent;
      cursor: pointer;
      padding: 0;
    }
    .cDot.active{
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Controls row */
    .controlRow{
      display:flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 14px;
    }
    .controlRow .left,
    .controlRow .right{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }

    footer{
      margin: 18px 0 10px;
      color: var(--muted);
      font-size: 12px;
      text-align:center;
    }

    @media (max-width: 780px){
      .topbar{ padding: 12px 14px; }
      .wrap{ padding: 14px; }
      #slide{ padding: 16px; }
    }
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div class="brand" aria-label="Slides header">
      <div class="logo" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M12 2l9 4v6c0 5-3.8 9.7-9 10-5.2-.3-9-5-9-10V6l9-4zm0 4.2L6 8.7v3.4c0 3.7 2.7 7.1 6 7.6 3.3-.5 6-3.9 6-7.6V8.7l-6-2.5z"/></svg>
      </div>
      <div>
        <h1>CompTIA A+ 1201 Slides</h1>
        <div class="subtitle">System Devices</div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="themeBtn" type="button" aria-label="Toggle theme">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 18a6 6 0 110-12 6 6 0 010 12zm0 4l-1-2h2l-1 2zM12 2l1 2h-2l1-2zM2 12l2-1v2l-2-1zm20 0l-2 1v-2l2 1zM4.2 4.2l2.1.7-1.4 1.4-.7-2.1zm15.6 15.6l-2.1-.7 1.4-1.4.7 2.1zM19.8 4.2l.7 2.1-1.4-1.4 2.1-.7zM4.2 19.8l-.7-2.1 1.4 1.4-2.1.7z"/></svg>
        <span id="themeLabel">Dark</span>
      </button>
    </div>
  </div>
</header>

<main class="wrap">
  <article class="panel" aria-label="Slides">
    <div class="hd">
      <strong>Slide viewer</strong>
      <span class="chip" id="counterChip"><b>Slide:</b> <span id="counterInline">1 / 1</span></span>
    </div>

    <div class="bd">
      <div class="titleRow">
        <h2 style="margin:0;">Installing System Devices</h2>
        <div class="chip"><b>Audio:</b> auto-detect (01.mp3…)</div>
      </div>

      <div id="slide"></div>

      <!-- Carousel container (auto-hides if no images) -->
      <div id="carouselWrap" style="display:none;">
        <div class="carousel">
          <div class="carouselTop">
            <div class="carouselBtns">
              <button class="btn" id="prevImgBtn" onclick="prevImage()">◀ Image</button>
              <button class="btn" id="nextImgBtn" onclick="nextImage()">Image ▶</button>
              <span class="chip" id="imgCounter"></span>
            </div>
            <div class="cDots" id="dots"></div>
          </div>

          <div class="carouselImgFrame">
            <img id="carouselImg" alt="Slide image" />
          </div>
        </div>
      </div>

      <div class="controlRow">
        <div class="left">
          <button class="btn" onclick="goHome()">Return Home</button>
          <button class="btn" onclick="goToFirstSlide()">First Slide</button>
          <button class="btn" onclick="prevSlide()">Previous</button>
          <button class="btn" onclick="nextSlide()">Next</button>
          <span class="chip" id="counter"></span>
        </div>

        <div class="right">
          <button class="btn" id="enableAudioBtn" onclick="enableAudio()">Enable audio</button>
          <button class="btn" id="replayBtn" onclick="replayAudio()" disabled>Replay audio</button>
        </div>
      </div>

      <audio id="slideAudio" preload="auto"></audio>
    </div>
  </article>

  <footer>
    Sudo-Antonio-Castro • CompTIA-APlus-1201-Slides
  </footer>
</main>

<script>
  // =========================
  // Theme toggle (persist)
  // =========================
  const themeBtn = document.getElementById("themeBtn");
  const themeLabel = document.getElementById("themeLabel");
  const savedTheme = localStorage.getItem("kb_theme");
  if (savedTheme) document.documentElement.setAttribute("data-theme", savedTheme);
  updateThemeLabel();

  themeBtn.addEventListener("click", () => {
    const current = document.documentElement.getAttribute("data-theme") || "light";
    const next = current === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", next);
    localStorage.setItem("kb_theme", next);
    updateThemeLabel();
  });

  function updateThemeLabel(){
    const current = document.documentElement.getAttribute("data-theme") || "light";
    themeLabel.textContent = current === "dark" ? "Light" : "Dark";
  }

  // ============================================================
  // SLIDES + AUDIO + CAROUSEL
  // ============================================================

  // Place this file at: System-Devices/index.html
  // Images: System-Devices/images/<filename>
  // Audio (recommended): System-Devices/audio/01.mp3, 02.mp3, ...
  // This script also supports: 1.mp3, 01.wav, 1.m4a, slide-01.mp3, etc.
  // If your audio is stored at repo root /audio instead, it will also try ../audio/.

  const pad2 = (n) => String(n).padStart(2, "0");

  // Slides were generated from the uploaded "A+ Module 3 PPT.pptx" content.
  const slides = [{"content":"<h2>Installing System Devices</h2><p>CompTIA A+ 1201</p>","images":[]},{"content":"<h2>Lessons</h2><ul><li>Power Supplies and Cooling</li><li>Storage Devices</li><li>System Memory</li><li>CPUs</li></ul>","images":[]},{"content":"<h2>Power Supply Units</h2><ul><li>A PSU’s main job is to convert wall power (AC) into the low-voltage DC power the PC actually uses.</li><li>Physical compatibility matters: PSU size/form factor must fit the case, and the PSU must support the motherboard’s required main power connector style.</li><li>Input voltage matters: some PSUs auto-switch for different regions, while others may require a selector switch. Plugging the wrong way can damage components.</li><li>PSUs provide multiple voltage rails (commonly 3.3V, 5V, and 12V DC) and supply power to both the motherboard and attached devices.</li><li>Good PSU choice isn’t just “it turns on”—it’s about stable power delivery under load, especially for systems with higher performance parts.</li></ul>","images":[]},{"content":"<h2>Wattage Rating</h2><ul><li>Wattage is the maximum power the PSU can supply; you match it to the system’s total demand (CPU, GPU, drives, fans, etc.).</li><li>Undersizing the PSU can cause random shutdowns, reboot loops, instability, and even component damage over time.</li><li>Beyond total watts, you also care about how the wattage is distributed across rails—modern systems lean heavily on the +12V rail.</li><li>Efficiency affects heat and power draw: a more efficient PSU wastes less energy as heat, helping reliability and cooling.</li><li>“80 PLUS” efficiency tiers (like Bronze/Silver/Gold) reflect how efficiently the PSU converts AC to DC at different loads.</li></ul>","images":[]},{"content":"<h2>Power Supply Connectors</h2><ul><li>The PSU uses different connectors to power different components—motherboard, CPU, drives, and PCIe add-on cards.</li><li>The main motherboard connector is commonly the 24-pin (P1) connector.</li><li>Drives commonly use SATA power; older/peripherals may use Molex.</li><li>CPUs and GPUs often require dedicated 4/6/8-pin (or higher) power connectors to handle higher current draw.</li><li>Matching the right connector type prevents boot failures and avoids dangerous “almost fits” situations.</li></ul>","images":[]},{"content":"<h2>20 + 4 Pin Motherboard Adapter</h2><ul><li>Older motherboards used a 20-pin ATX main power connector; most modern systems use 24-pin.</li><li>An adapter (or a “20+4” design) allows compatibility between a legacy PSU and a newer motherboard in some cases.</li><li>The additional pins help provide extra power capacity and stability for modern boards.</li><li>Always verify the PSU can support the board’s power needs—an adapter doesn’t magically increase available wattage.</li></ul>","images":[]},{"content":"<h2>Modular Power Supplies</h2><ul><li>Modular PSUs have detachable cables, so you only install the cables you actually need.</li><li>Benefits: less cable clutter, easier routing, and better airflow inside the case (which helps cooling).</li><li>It can also improve serviceability (simpler swaps, cleaner troubleshooting).</li><li>The performance isn’t automatically better than non-modular—modularity is mainly about build quality and airflow/cable management.</li></ul>","images":[]},{"content":"<h2>Redundant Power Supplies</h2><ul><li>Redundant PSUs are common in servers/data centers where uptime is critical.</li><li>Two PSUs can provide failover—if one PSU dies, the other keeps the system running.</li><li>Many redundant PSU setups are hot-swappable (replace without shutting down), which is huge for business continuity.</li><li>This is much less common in standard desktops because it adds cost and complexity.</li></ul>","images":[]},{"content":"<h2>Fan Cooling Systems</h2><ul><li>Heat is a normal byproduct of electricity moving through components; too much heat causes throttling, instability, and hardware damage.</li><li>A fan cooling system depends on airflow design: intake brings cool air in, exhaust removes hot air out.</li><li>Good airflow is about a clean “path” through the case—not just stuffing in more fans.</li><li>Dust buildup blocks airflow and insulation-like dust layers trap heat, so cleaning is part of maintenance.</li></ul>","images":[]},{"content":"<h2>Heat Sinks and Thermal Paste</h2><ul><li>A heat sink pulls heat away by using high surface area (fins) to transfer heat to the air.</li><li>Thermal paste (or a thermal pad) fills microscopic gaps between the CPU and heat sink so heat transfers efficiently.</li><li>Without proper paste/contact, you get hot spots, poor cooling, and potential CPU shutdowns under load.</li><li>Heat sinks can be passive or paired with fans; CPUs typically use an active setup for reliable cooling.</li></ul>","images":[]},{"content":"<h2>Fans</h2><ul><li>Fans may be mounted as front/side intake and rear/top exhaust to create a consistent airflow pattern.</li><li>CPU fans often mount directly to the heat sink; case fans manage overall chassis temperature.</li><li>Balanced airflow matters: too much exhaust without intake can pull dust in through gaps; too much intake without exhaust traps heat.</li><li>Many systems use fan control (BIOS/UEFI or OS utilities) to adjust speeds based on temperature.</li></ul>","images":[]},{"content":"<h2>Liquid Cooling</h2><ul><li>Liquid cooling moves heat via a loop rather than relying only on air at the CPU.</li><li>Core parts of an open-loop system include tubing/loop + pump, water block, and a radiator + fans.</li><li>Liquid cooling can be quieter and better at handling sustained high loads, but it adds complexity.</li><li>Open-loop systems require periodic maintenance (checking fluid, cleaning, potentially draining/refilling).</li><li>Closed-loop/AIO coolers reduce maintenance and installation complexity compared to open-loop setups.</li></ul>","images":[]},{"content":"<h2>Lesson 3.2 Storage Devices</h2>","images":[]},{"content":"<h2>Mass Storage Devices</h2><ul><li>“Mass storage” refers to non-volatile storage (data remains when power is off).</li><li>Storage choices are usually evaluated by reliability, performance, and use case (office PC vs gaming vs server vs backups).</li><li>Drives may be internal (mounted in bays) or external/removable (connected by USB/other interfaces).</li><li>Form factors and bay sizes matter (common internal sizes include 2.5&quot; and 3.5&quot;, and 5.25&quot; bays for optical).</li></ul>","images":[]},{"content":"<h2>Solid State Drives (SSDs)</h2><ul><li>SSDs store data on flash memory with no moving parts, making them fast and resistant to mechanical shock.</li><li>They typically provide faster boot times, application launches, and general responsiveness than HDDs.</li><li>Flash memory has limited write endurance; controllers use techniques like wear leveling to spread writes and extend lifespan.</li><li>SSD interfaces include:<ul><li>SATA SSDs (common, easy upgrade path, but bandwidth-limited compared to PCIe)</li><li>PCIe/NVMe SSDs (very high performance, often in M.2 form factor)</li><li>Other enterprise/high-performance options like SAS depending on environment</li></ul></li><li>Cost per GB is usually higher than HDDs, so SSD/HDD combos are common (SSD for OS/apps, HDD for bulk storage).</li></ul>","images":[]},{"content":"<h2>Hard Disk Drives (HDDs)</h2><ul><li>HDDs use spinning platters and read/write heads—mechanical parts that can wear out or fail from shock.</li><li>They offer large capacities at low cost per GB, making them great for bulk storage and backups.</li><li>HDD performance depends on RPM (5400 vs 7200 vs 10k), cache, and interface.</li><li>Because they’re mechanical, HDDs are slower than SSDs for random access and boot/app loads.</li></ul>","images":[]},{"content":"<h2>Redundant Array of Independent Disks (RAID)</h2><ul><li>RAID combines multiple drives to improve performance, redundancy, or both.</li><li>Different RAID levels offer different tradeoffs (speed vs fault tolerance).</li><li>RAID is not the same as backup—arrays can still fail or suffer data corruption, so backups are still needed.</li><li>Hardware vs software RAID: hardware uses a controller, software uses the OS; each has pros/cons.</li></ul>","images":[]},{"content":"<h2>Raid 0 and Raid 1</h2><div style=\"display:flex; gap:24px; align-items:flex-start; flex-wrap:wrap;\"><div style=\"flex:1; min-width:260px;\"><ul><li>RAID 0 uses striping (splitting data across drives) to improve performance.</li><li>Requires at least two drives.</li><li>Major downside: no redundancy—if one drive fails, the entire array fails.</li><li>Best fit: performance-focused situations where data loss is acceptable (scratch disk, non-critical workloads).</li></ul></div><div style=\"flex:1; min-width:260px;\"><ul><li>RAID 1 uses mirroring (same data written to two drives).</li><li>Requires at least two drives.</li><li>Strength: strong redundancy—if one drive fails, data is still available on the other drive.</li><li>Tradeoff: usable capacity is effectively 50% (because data is duplicated).</li></ul></div></div>","images":[]},{"content":"<h2>RAID 5 and RAID 10</h2><div style=\"display:flex; gap:24px; align-items:flex-start; flex-wrap:wrap;\"><div style=\"flex:1; min-width:260px;\"><ul><li>RAID 5 uses striping with distributed parity (error recovery info spread across drives).</li><li>Requires at least three drives.</li><li>Advantage: can survive one drive failure while keeping data accessible.</li><li>Tradeoff: writes are slower than RAID 0/1 because parity must be calculated and written. </li></ul></div><div style=\"flex:1; min-width:260px;\"><ul><li>RAID 10 combines RAID 1 and RAID 0 (often described as a stripe of mirrors).</li><li>Requires at least four drives (and usually an even number).</li><li>Provides excellent performance and strong fault tolerance—one drive in each mirrored pair can fail without losing the array.</li><li>Common fit: high-performance environments where uptime matters (databases, heavy workloads).</li></ul></div></div>","images":[]},{"content":"<h2>RAID 6</h2><ul><li>RAID 6 is similar to RAID 5 but uses double parity.</li><li>Requires at least four drives.</li><li>Advantage: can tolerate two drive failures (stronger fault tolerance than RAID 5).</li><li>Tradeoff: slower writes and less usable capacity due to additional parity overhead.</li></ul>","images":[]},{"content":"<h2>Removable Storage Drives</h2><ul><li>Removable storage includes external HDDs/SSDs, USB flash drives, memory cards, and other portable media.</li><li>Common interfaces: USB, USB-C, Thunderbolt; performance depends on both the drive and the connection standard.</li><li>Use cases: backups, file transfer, imaging/boot media, and portability.</li><li>Security considerations: easy to lose; encryption and access controls are recommended for sensitive data.</li></ul>","images":[]},{"content":"<h2>Optical Drives</h2><ul><li>Optical drives read/write removable discs (CD/DVD/Blu-ray).</li><li>Less common now, but still used for legacy media, software installs, and archival storage.</li><li>Speed and capacity vary: CD (~700MB), DVD (~4.7GB single-layer), Blu-ray (25GB+).</li><li>They often use SATA internally or USB externally.</li></ul>","images":[]},{"content":"<h2>Lesson 3.3 System Memory</h2>","images":[]},{"content":"<h2>System RAM and Virtual Memory</h2><ul><li>RAM is fast working memory used for active programs; it’s volatile (clears when power is off).</li><li>When RAM is insufficient, systems use virtual memory (paging/swapping to storage) to keep running. Slower than real RAM, but better than crashing.</li><li>Memory addressing concepts matter:</li><ul><li>Data pathway influences how much data moves per clock cycle.</li><li>Address pathway influences how many memory locations can be accessed.</ul></li><li>32-bit vs 64-bit addressing impacts how much memory can be utilized and how large the address space can be. </li></ul>","images":[]},{"content":"<h2>RAM Types</h2><ul><li>Core RAM families include DRAM/SDRAM and DDR generations (DDR3/DDR4/DDR5), each has different electrical and physical design constraints.</li><li>DDR (Double Data Rate) improves throughput by transferring data more efficiently per clock cycle compared to earlier designs.</li><li>RAM performance is described using metrics like data rate (MT/s), bandwidth/transfer rate, and timings.</li></ul>","images":[]},{"content":"<h2>Memory Modules</h2><ul><li>RAM chips are packaged into modules:</li><li>DIMMs are common in desktops.</li><li>SODIMMs are common in laptops and compact devices.</li><li>Modules are keyed (notches) so the wrong DDR generation won’t physically fit the slot correctly.</li><li>Proper installation includes seating firmly, using the correct slots, and following ESD-safe handling practices.</li><li>Mixing RAM speeds/types usually causes the system to downclock to the slowest common settings—or fail to boot if incompatible. </li></ul>","images":[]},{"content":"<h2>Multi Channel System Memory</h2><ul><li>Single-channel uses one 64-bit data path; dual-channel uses two 64-bit paths (effectively increasing bandwidth).</li><li>Dual-channel configuration depends on correct slot population (motherboards often color-code paired slots).</li><li>Best results come from matching modules (same capacity, speed, timings) otherwise you can trigger mismatched behavior or reduced performance.</li><li>Some systems support “flex mode,” where part of memory runs dual-channel and the remainder runs single-channel when capacities don’t match.</li><li>Higher-end platforms may support triple-channel or quad-channel, requiring CPU support and specific module population rules.</li></ul>","images":[]},{"content":"<h2>ECC RAM</h2><ul><li>ECC (Error-Correcting Code) RAM can detect and correct certain memory errors, improving stability.</li><li>It's most common in servers/workstations where uptime and data integirty matter.</li><li>ECC requires compatibility across the CPU, motherboard, and memory type - ECC/Non ECC mixing is typically not supported.</li><li>Some ECC implementations use registered/buffered designs for stability with large memory configurations (common in enterprise environments).</li></ul>","images":[]},{"content":"<h2>Lesson 3.4 CPUs</h2>","images":[]},{"content":"<h2>CPU Architecture</h2><ul><li>The CPU’s instruction set architecture (ISA) defines how it executes machine code.</li><li>Common architectures: x86, x64, ARM.</li><li>Architecture impacts compatibility with operating systems and software.</li></ul>","images":[]},{"content":"<h2>X86 CPU Architecture</h2><ul><li>x86 is a 32-bit architecture widely used in older PCs.</li><li>32-bit addressing limits usable RAM compared to 64-bit.</li><li>Some older operating systems and applications are designed specifically for x86.</li></ul>","images":[]},{"content":"<h2>X64 CPU Architecture</h2><ul><li>x64 is a 64-bit architecture used in modern desktop and laptop CPUs.</li><li>Supports much larger memory addressing than x86.</li><li>Most modern operating systems and applications target x64 platforms.</li><li>Can often run 32-bit applications via compatibility layers.</li></ul>","images":[]},{"content":"<h2>ARM CPU Architecture</h2><ul><li>ARM is common in mobile devices, embedded systems, and increasingly in laptops/servers.</li><li>Known for power efficiency and strong performance-per-watt.</li><li>Software compatibility depends on OS and application support for ARM.</li></ul>","images":[]},{"content":"<h2>CPU Features</h2><ul><li>Common CPU features include virtualization support, integrated graphics, power management, and advanced instruction sets.</li><li>Virtualization extensions (Intel VT-x/AMD-V) improve VM performance.</li><li>Cache (L1/L2/L3) improves speed by storing frequently used data close to the CPU cores.</li><li>Thermal/power limits affect sustained performance and cooling requirements.</li></ul>","images":[]},{"content":"<h2>CPU Socket Types</h2><ul><li>CPU socket type must match the motherboard.</li><li>Intel and AMD use different socket families; even within a family, chipset/BIOS support matters.</li><li>Never force a CPU into a socket—alignment and correct orientation are required.</li></ul>","images":[]},{"content":"<h2>CPU Types and Motherboard Compatibility</h2><ul><li>Compatibility is primarily about socket, chipset, and BIOS support.</li><li>Feature support like PCIe version, memory type, and integrated graphics can matter too.</li><li>Consider core count, thermal requirements, and intended workload when selecting a CPU.</li></ul>","images":[]}];

  // Slide state
  let index = 0;

  // Carousel state (for current slide)
  let imgIndex = 0;

  // Audio state
  let audioEnabled = false;

  // ---- Audio resolution (supports many filename styles) ----
  const AUDIO_FOLDERS = ["audio", "../audio"];
  const AUDIO_BASES = (n) => [pad2(n), String(n), `slide-${pad2(n)}`, `slide-${n}`];
  const AUDIO_EXTS = ["mp3", "m4a", "wav", "ogg"];

  const audioSrcCache = new Map(); // slideNumber (1-based) -> resolved src string

  async function urlExists(url) {
    try {
      const head = await fetch(url, { method: "HEAD", cache: "no-store" });
      if (head.ok) return true;

      // Some hosts don’t like HEAD; try tiny ranged GET
      const get = await fetch(url, {
        method: "GET",
        headers: { "Range": "bytes=0-0" },
        cache: "no-store"
      });
      return get.ok;
    } catch (e) {
      return false;
    }
  }

  async function resolveAudioSrc(slideNumber) {
    if (audioSrcCache.has(slideNumber)) return audioSrcCache.get(slideNumber);

    const candidates = [];
    for (const folder of AUDIO_FOLDERS) {
      for (const base of AUDIO_BASES(slideNumber)) {
        for (const ext of AUDIO_EXTS) {
          candidates.push(`${folder}/${base}.${ext}`);
          candidates.push(`${folder}/${base}.${ext.toUpperCase()}`);
        }
      }
    }

    for (const c of candidates) {
      if (await urlExists(c)) {
        audioSrcCache.set(slideNumber, c);
        return c;
      }
    }

    console.log(`[audio] No audio file found for slide ${slideNumber}. Tried:`, candidates);
    return null;
  }

  async function playCurrentAudio() {
    if (!audioEnabled) return;

    const audio = document.getElementById("slideAudio");
    audio.pause();
    audio.currentTime = 0;

    // Optional per-slide override:
    // slides[i].audio = "audio/customname.mp3"  OR  slides[i].audio = false to disable
    let src = slides[index].audio;
    if (src === false) return;

    if (typeof src !== "string" || !src.trim()) {
      src = await resolveAudioSrc(index + 1);
    }
    if (!src) return;

    const abs = new URL(src, window.location.href).href;
    if (audio.src !== abs) {
      audio.src = src;
      audio.load();
    }

    try {
      await audio.play();
    } catch (err) {
      console.log("[audio] Play blocked or missing file:", err);
    }
  }

  function enableAudio() {
    audioEnabled = true;
    document.getElementById("replayBtn").disabled = false;
    playCurrentAudio();
  }

  function replayAudio() {
    playCurrentAudio();
  }

  // ---- Carousel ----
  function renderCarousel() {
    const wrap = document.getElementById("carouselWrap");
    const imgEl = document.getElementById("carouselImg");
    const dotsEl = document.getElementById("dots");
    const imgCounter = document.getElementById("imgCounter");
    const prevBtn = document.getElementById("prevImgBtn");
    const nextBtn = document.getElementById("nextImgBtn");

    const filenames = (slides[index].images || []).filter(Boolean);

    if (filenames.length === 0) {
      wrap.style.display = "none";
      return;
    }

    wrap.style.display = "block";

    if (imgIndex < 0) imgIndex = 0;
    if (imgIndex > filenames.length - 1) imgIndex = filenames.length - 1;

    imgEl.src = `images/${filenames[imgIndex]}`;
    imgCounter.textContent = `Image ${imgIndex + 1} / ${filenames.length}`;

    prevBtn.disabled = (filenames.length <= 1) || (imgIndex === 0);
    nextBtn.disabled = (filenames.length <= 1) || (imgIndex === filenames.length - 1);

    dotsEl.innerHTML = "";
    if (filenames.length > 1) {
      filenames.forEach((_, i) => {
        const b = document.createElement("button");
        b.className = "cDot" + (i === imgIndex ? " active" : "");
        b.title = `Go to image ${i + 1}`;
        b.onclick = () => { imgIndex = i; renderCarousel(); };
        dotsEl.appendChild(b);
      });
    }
  }

  function nextImage() {
    const filenames = (slides[index].images || []).filter(Boolean);
    if (imgIndex < filenames.length - 1) {
      imgIndex++;
      renderCarousel();
    }
  }

  function prevImage() {
    if (imgIndex > 0) {
      imgIndex--;
      renderCarousel();
    }
  }

  // ---- Slides ----
  function updateCounters() {
    const t = `Slide ${index + 1} / ${slides.length}`;
    document.getElementById("counter").textContent = t;
    document.getElementById("counterInline").textContent = `${index + 1} / ${slides.length}`;
  }

  function showSlide() {
    document.getElementById("slide").innerHTML = slides[index].content;
    updateCounters();

    imgIndex = 0;
    renderCarousel();

    playCurrentAudio();
  }

  function nextSlide() {
    if (index < slides.length - 1) index++;
    showSlide();
  }

  function prevSlide() {
    if (index > 0) index--;
    showSlide();
  }

  function goToFirstSlide() {
    index = 0;
    showSlide();
  }

  function goHome() {
    window.location.href = "../";
  }

  // Keyboard:
  // Left/Right = slide nav
  // A/D = image nav
  // Home = first slide
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowRight") nextSlide();
    if (e.key === "ArrowLeft") prevSlide();
    if (e.key.toLowerCase() === "d") nextImage();
    if (e.key.toLowerCase() === "a") prevImage();
    if (e.key === "Home") goToFirstSlide();
  });

  showSlide();
</script>

</body>
</html>
