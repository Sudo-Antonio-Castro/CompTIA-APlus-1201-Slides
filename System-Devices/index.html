<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CompTIA A+ 1201 — System Devices</title>
  <meta name="description" content="CompTIA A+ 1201 Slides — Module 3: Installing System Devices" />

  <style>
    /* ======================= */
    /* KB Black/White Template */
    /* ======================= */

    :root{
      --bg: #ffffff;
      --panel: #ffffff;
      --text: #0b0b0f;
      --muted: #5b5b66;
      --border: #e6e6ee;
      --shadow: 0 6px 30px rgba(0,0,0,.08);
      --accent: #111111;
      --accent-2: #2b2b2b;
      --chip:#f2f2f7;
      --link:#111111;
      --focus: 0 0 0 3px rgba(0,0,0,.18);
      --radius: 14px;
      --radius-sm: 10px;
      --max: 1200px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }

    [data-theme="dark"]{
      --bg: #0b0b0f;
      --panel: #101014;
      --text: #f6f6fb;
      --muted: #b5b5c2;
      --border: #262633;
      --shadow: 0 10px 40px rgba(0,0,0,.40);
      --accent: #ffffff;
      --accent-2: #e7e7ef;
      --chip:#17171e;
      --link:#f6f6fb;
      --focus: 0 0 0 3px rgba(255,255,255,.18);
    }

    *{ box-sizing:border-box; }
    html{ scroll-behavior:smooth; }
    body{
      margin:0;
      font-family: var(--font);
      color: var(--text);
      background: var(--bg);
      line-height: 1.55;
    }
    a{ color:var(--link); text-decoration: none; }
    a:hover{ text-decoration: underline; }
    :focus-visible{ outline:none; box-shadow: var(--focus); border-radius: 8px; }

    /* Layout */
    .wrap{ max-width: var(--max); margin: 0 auto; padding: 18px; }

    header{
      position: sticky;
      top:0;
      z-index: 30;
      background: color-mix(in oklab, var(--bg) 88%, transparent);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
    }
    .topbar{
      display:flex;
      align-items:center;
      gap:12px;
      justify-content: space-between;
      padding: 14px 18px;
      max-width: var(--max);
      margin:0 auto;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 240px;
    }
    .logo{
      width:34px;height:34px;border-radius: 10px;
      background: var(--accent);
      box-shadow: var(--shadow);
      display:grid; place-items:center;
      flex: 0 0 auto;
    }
    .logo svg{ width:18px; height:18px; fill: var(--bg); }
    [data-theme="dark"] .logo svg{ fill: #0b0b0f; }

    .brand h1{
      font-size: 14px;
      margin:0;
      letter-spacing: .08em;
      text-transform: uppercase;
      opacity:.9;
    }
    .subtitle{
      font-size:12px;
      color: var(--muted);
      margin-top:2px;
    }

    .controls{
      display:flex; align-items:center; gap:10px;
      justify-content: flex-end;
    }

    .btn{
      border:1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: none;
      user-select:none;
      font-family: var(--font);
    }
    .btn:hover{ border-color: color-mix(in oklab, var(--border) 70%, var(--accent)); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn svg{ width:16px; height:16px; fill: var(--text); opacity:.85; }

    .panel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .panel .hd{
      padding: 14px 16px 12px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .panel .hd strong{
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .panel .bd{ padding: 16px; }

    .titleRow{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .titleRow h2{
      font-size: 22px;
      margin: 0;
      letter-spacing: -0.02em;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: var(--chip);
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .chip b{ color: var(--text); font-weight:600; }

    /* Slide box (content area) */
    #slide{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      padding: 22px;
      min-height: 220px;
    }
    #slide h2{ margin: 0 0 10px; font-size: 22px; letter-spacing: -0.01em; }
    #slide h3{ margin: 14px 0 8px; font-size: 16px; }
    #slide p{ margin: 10px 0; color: color-mix(in oklab, var(--text) 92%, var(--muted)); }
    #slide ul, #slide ol{ margin: 10px 0 10px 18px; color: color-mix(in oklab, var(--text) 92%, var(--muted)); }
    #slide hr{ border: none; height:1px; background: var(--border); margin: 16px 0; }

    /* Carousel */
    #carouselWrap{
      margin-top: 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--panel);
      padding: 14px;
    }
    .carousel{
      display:grid;
      gap: 10px;
    }
    .carouselTop{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap:10px;
      flex-wrap: wrap;
    }
    .carouselBtns{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .carouselImgFrame{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: color-mix(in oklab, var(--chip) 55%, transparent);
      padding: 10px;
      min-height: 260px;
      display:grid;
      place-items:center;
      overflow:hidden;
    }
    #carouselImg{
      max-width: 100%;
      height: auto;
      display:block;
      border-radius: var(--radius-sm);
    }

    /* IMPORTANT: avoid collision with KB template's ".dot" usage */
    .cDots{
      display:flex;
      gap:6px;
      flex-wrap: wrap;
      align-items:center;
    }
    .cDot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid color-mix(in oklab, var(--border) 65%, var(--accent));
      background: transparent;
      cursor: pointer;
      padding: 0;
    }
    .cDot.active{
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Controls row */
    .controlRow{
      display:flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 14px;
    }
    .controlRow .left,
    .controlRow .right{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }

    footer{
      margin: 18px 0 10px;
      color: var(--muted);
      font-size: 12px;
      text-align:center;
    }

    @media (max-width: 780px){
      .topbar{ padding: 12px 14px; }
      .wrap{ padding: 14px; }
      #slide{ padding: 16px; }
    }
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div class="brand" aria-label="Slides header">
      <div class="logo" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M12 2l9 4v6c0 5-3.8 9.7-9 10-5.2-.3-9-5-9-10V6l9-4zm0 4.2L6 8.7v3.4c0 3.7 2.7 7.1 6 7.6 3.3-.5 6-3.9 6-7.6V8.7l-6-2.5z"/></svg>
      </div>
      <div>
        <h1>CompTIA A+ 1201 Slides</h1>
        <div class="subtitle">System Devices — Module 3</div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="themeBtn" type="button" aria-label="Toggle theme">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 18a6 6 0 110-12 6 6 0 010 12zm0 4l-1-2h2l-1 2zM12 2l1 2h-2l1-2zM2 12l2-1v2l-2-1zm20 0l-2 1v-2l2 1zM4.2 4.2l2.1.7-1.4 1.4-.7-2.1zm15.6 15.6l-2.1-.7 1.4-1.4.7 2.1zM19.8 4.2l.7 2.1-1.4-1.4 2.1-.7zM4.2 19.8l-.7-2.1 1.4 1.4-2.1.7z"/></svg>
        <span id="themeLabel">Dark</span>
      </button>
    </div>
  </div>
</header>

<main class="wrap">
  <article class="panel" aria-label="Slides">
    <div class="hd">
      <strong>Slide viewer</strong>
      <span class="chip" id="counterChip"><b>Slide:</b> <span id="counterInline">1 / 1</span></span>
    </div>

    <div class="bd">
      <div class="titleRow">
        <h2 style="margin:0;">Installing System Devices</h2>
        <div class="chip"><b>Audio:</b> auto-detect (01.mp3…)</div>
      </div>

      <div id="slide"></div>

      <!-- Carousel container (auto-hides if no images) -->
      <div id="carouselWrap" style="display:none;">
        <div class="carousel">
          <div class="carouselTop">
            <div class="carouselBtns">
              <button class="btn" id="prevImgBtn" onclick="prevImage()">
                ◀ Image
              </button>
              <button class="btn" id="nextImgBtn" onclick="nextImage()">
                Image ▶
              </button>
              <span class="chip" id="imgCounter"></span>
            </div>
            <div class="cDots" id="dots"></div>
          </div>

          <div class="carouselImgFrame">
            <img id="carouselImg" alt="Slide image" />
          </div>
        </div>
      </div>

      <div class="controlRow">
        <div class="left">
          <button class="btn" onclick="goHome()">Return Home</button>
          <button class="btn" onclick="goToFirstSlide()">First Slide</button>
          <button class="btn" onclick="prevSlide()">Previous</button>
          <button class="btn" onclick="nextSlide()">Next</button>
          <span class="chip" id="counter"></span>
        </div>

        <div class="right">
          <button class="btn" id="enableAudioBtn" onclick="enableAudio()">Enable audio</button>
          <button class="btn" id="replayBtn" onclick="replayAudio()" disabled>Replay audio</button>
        </div>
      </div>

      <audio id="slideAudio" preload="auto"></audio>
    </div>
  </article>

  <footer>
    Sudo-Antonio-Castro • CompTIA-APlus-1201-Slides
  </footer>
</main>

<script>
  // =========================
  // Theme toggle (persist)
  // =========================
  const themeBtn = document.getElementById("themeBtn");
  const themeLabel = document.getElementById("themeLabel");
  const savedTheme = localStorage.getItem("kb_theme");
  if (savedTheme) document.documentElement.setAttribute("data-theme", savedTheme);
  updateThemeLabel();

  themeBtn.addEventListener("click", () => {
    const current = document.documentElement.getAttribute("data-theme") || "light";
    const next = current === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", next);
    localStorage.setItem("kb_theme", next);
    updateThemeLabel();
  });

  function updateThemeLabel(){
    const current = document.documentElement.getAttribute("data-theme") || "light";
    themeLabel.textContent = current === "dark" ? "Light" : "Dark";
  }

  // ============================================================
  // SLIDES + AUDIO + CAROUSEL (unchanged behavior)
  // ============================================================

  // Place this file at: System-Devices/index.html
  // Recommended audio naming (in System-Devices/audio/):
  //   01.mp3, 02.mp3, 03.mp3, ...
  // This script also supports: 1.mp3, 1.wav, 01.wav, 1.m4a, etc.
  // If your audio is stored at repo root /audio instead, it will also try ../audio/.

  const pad2 = (n) => String(n).padStart(2, "0");

  const slides = [{"content":"<h2>Module 3: Installing System Devices</h2><p>CompTIA A+ 1201</p>","images":[]},{"content":"<h2>Lessons</h2><ul><li>Power Supplies and Cooling</li><li>Storage Devices</li><li>System Memory</li><li>CPUs</li></ul>","images":[]},{"content":"<h2>Power Supply Units</h2><ul><li>A PSU’s main job is to convert wall power (AC) into the low-voltage DC power the PC actually uses.</li><li>Physical compatibility matters: PSU size/form factor must fit the case, and the PSU must support the motherboard’s required main power connector style.</li><li>Input voltage matters: some PSUs auto-switch for different regions, while others may require a selector switch—plugging the wrong way can damage components.</li><li>PSUs provide multiple voltage rails (commonly 3.3V, 5V, and 12V DC) and supply power to both the motherboard and attached devices.</li><li>Good PSU choice isn’t just “it turns on”—it’s about stable power delivery under load, especially for systems with higher performance parts.</li></ul>","images":[]},{"content":"<h2>Wattage Rating</h2><ul><li>Wattage is the maximum power the PSU can supply; you match it to the system’s total demand (CPU, GPU, drives, fans, etc.).</li><li>Undersizing the PSU can cause random shutdowns, reboot loops, instability, and even component damage over time.</li><li>Beyond total watts, you also care about how the wattage is distributed across rails—modern systems lean heavily on the +12V rail.</li><li>Efficiency affects heat and power draw: a more efficient PSU wastes less energy as heat, helping reliability and cooling.</li><li>“80 PLUS” efficiency tiers (like Bronze/Silver/Gold) reflect how efficiently the PSU converts AC to DC at different loads.</li></ul>","images":[]},{"content":"<h2>Power Supply Connectors</h2><ul><li>The PSU uses different connectors to power different components—motherboard, CPU, drives, and PCIe add-on cards.</li><li>The main motherboard connector is commonly the 24-pin (P1) connector.</li><li>Drives commonly use SATA power; older/peripherals may use Molex.</li><li>CPUs and GPUs often require dedicated 4/6/8-pin (or higher) power connectors to handle higher current draw.</li><li>Matching the right connector type prevents boot failures and avoids dangerous “almost fits” situations.</li></ul>","images":[]},{"content":"<h2>20 + 4 Pin Motherboard Adapter</h2><ul><li>Older motherboards used a 20-pin ATX main power connector; most modern systems use 24-pin.</li><li>An adapter (or a “20+4” design) allows compatibility between a legacy PSU and a newer motherboard in some cases.</li><li>The additional pins help provide extra power capacity and stability for modern boards.</li><li>Always verify the PSU can support the board’s power needs—an adapter doesn’t magically increase available wattage.</li></ul>","images":[]},{"content":"<h2>Modular Power Supplies</h2><ul><li>Modular PSUs have detachable cables, so you only install the cables you actually need.</li><li>Benefits: less cable clutter, easier routing, and better airflow inside the case (which helps cooling).</li><li>It can also improve serviceability (simpler swaps, cleaner troubleshooting).</li><li>The performance isn’t automatically better than non-modular—modularity is mainly about build quality and airflow/cable management.</li></ul>","images":[]},{"content":"<h2>Redundant Power Supplies</h2><ul><li>Redundant PSUs are common in servers/data centers where uptime is critical.</li><li>Two PSUs can provide failover—if one PSU dies, the other keeps the system running.</li><li>Many redundant PSU setups are hot-swappable (replace without shutting down), which is huge for business continuity.</li><li>This is much less common in standard desktops because it adds cost and complexity.</li></ul>","images":[]},{"content":"<h2>Fan Cooling Systems</h2><ul><li>Heat is a normal byproduct of electricity moving through components; too much heat causes throttling, instability, and hardware damage.</li><li>A fan cooling system depends on airflow design: intake brings cool air in, exhaust removes hot air out.</li><li>Good airflow is about a clean “path” through the case—not just stuffing in more fans.</li><li>Dust buildup blocks airflow and insulation-like dust layers trap heat, so cleaning is part of maintenance.</li></ul>","images":[]},{"content":"<h2>Heat Sinks and Thermal Paste</h2><ul><li>A heat sink pulls heat away by using high surface area (fins) to transfer heat to the air.</li><li>Thermal paste (or a thermal pad) fills microscopic gaps between the CPU and heat sink so heat transfers efficiently.</li><li>Without proper paste/contact, you get hot spots, poor cooling, and potential CPU shutdowns under load.</li><li>Heat sinks can be passive or paired with fans; CPUs typically use an active setup for reliable cooling.</li></ul>","images":[]},{"content":"<h2>Fans</h2><ul><li>Fans may be mounted as front/side intake and rear/top exhaust to create a consistent airflow pattern.</li><li>CPU fans often mount directly to the heat sink; case fans manage overall chassis temperature.</li><li>Balanced airflow matters: too much exhaust without intake can pull dust in through gaps; too much intake without exhaust traps heat.</li><li>Many systems use fan control (BIOS/UEFI or OS utilities) to adjust speeds based on temperature.</li></ul>","images":[]},{"content":"<h2>Liquid Cooling</h2><ul><li>Liquid cooling moves heat via a loop rather than relying only on air at the CPU.</li><li>Core parts of an open-loop system include tubing/loop + pump, water block, and a radiator + fans.</li><li>Liquid cooling can be quieter and better at handling sustained high loads, but it adds complexity.</li><li>Open-loop systems require periodic maintenance (checking fluid, cleaning, potentially draining/refilling).</li><li>Closed-loop/AIO coolers reduce maintenance and installation complexity compared to open-loop setups.</li></ul>","images":[]},{"content":"<h2>Lesson 3.2 Storage Devices</h2>","images":[]},{"content":"<h2>Mass Storage Devices</h2><ul><li>“Mass storage” refers to non-volatile storage (data remains when power is off).</li><li>Storage choices are usually evaluated by reliability, performance, and use case (office PC vs gaming vs server vs backups).</li><li>Drives may be internal (mounted in bays) or external/removable (connected by USB/other interfaces).</li><li>Form factors and bay sizes matter (common internal sizes include 2.5\" and 3.5\", and 5.25\" bays for optical).</li></ul>","images":[]},{"content":"<h2>Solid State Drives (SSDs)</h2><ul><li>SSDs store data on flash memory with no moving parts, making them fast and resistant to mechanical shock.</li><li>They typically provide faster boot times, application launches, and general responsiveness than HDDs.</li><li>Flash memory has limited write endurance; controllers use techniques like wear leveling to spread writes and extend lifespan.</li><li>SSD interfaces include:</li><li>SATA SSDs (common, easy upgrade path, but bandwidth-limited compared to PCIe)</li><li>PCIe/NVMe SSDs (very high performance, often in M.2 form factor)</li><li>Other enterprise/high-performance options like SAS depending on environment</li><li>Cost per GB is usually higher than HDDs, so SSD/HDD combos are common (SSD for OS/apps, HDD for bulk storage).</li></ul>","images":[]},{"content":"<h2>Hard Disk Drives (HDDs)</h2><ul><li>HDDs use spinning platters and read/write heads—mechanical parts that can wear out or fail from shock.</li><li>They offer large capacities at low cost per GB, making them great for bulk storage and backups.</li><li>HDD performance depends on RPM (5400 vs 7200 vs 10k), cache, and interface.</li><li>Because they’re mechanical, HDDs are slower than SSDs for random access and boot/app loads.</li></ul>","images":[]},{"content":"<h2>Redundant Array of Independent Disks (RAID)</h2><ul><li>RAID combines multiple drives into one logical unit to improve performance, fault tolerance, or both.</li><li>Different RAID “levels” trade off speed vs redundancy vs capacity.</li><li>RAID is not a backup—RAID protects against drive failure, not accidental deletion, malware, or corruption.</li></ul>","images":[]},{"content":"<h2>Raid 0 and Raid 1</h2><div style=\"display:flex; gap:24px; align-items:flex-start;\"><div style=\"flex:1; min-width:0;\"><ul><li>RAID 0 uses striping (splitting data across drives) to improve performance.</li><li>Requires at least two drives.</li><li>Major downside: no redundancy—if one drive fails, the entire array fails.</li><li>Best fit: performance-focused situations where data loss is acceptable (scratch disk, non-critical workloads).</li></ul></div><div style=\"flex:1; min-width:0;\"><ul><li>RAID 1 uses mirroring (same data written to two drives).</li><li>Requires at least two drives.</li><li>Benefit: redundancy—if one drive fails, the other still has the data.</li><li>Downside: usable capacity is effectively 50% (because data is duplicated).</li></ul></div></div>","images":[]},{"content":"<h2>RAID 5 and RAID 10</h2><div style=\"display:flex; gap:24px; align-items:flex-start;\"><div style=\"flex:1; min-width:0;\"><ul><li>RAID 5 uses striping with distributed parity (error recovery info spread across drives).</li><li>Requires at least three drives.</li><li>Can survive one drive failure without losing data.</li><li>Good balance of capacity and fault tolerance, but writes can be slower due to parity calculations.</li></ul></div><div style=\"flex:1; min-width:0;\"><ul><li>RAID 10 combines RAID 1 and RAID 0 (often described as a stripe of mirrors).</li><li>Requires at least four drives (and usually an even number).</li><li>Excellent performance and redundancy, but capacity is reduced due to mirroring.</li><li>Common in high-performance environments where uptime matters (databases, heavy workloads).</li></ul></div></div>","images":[]},{"content":"<h2>RAID 6</h2><ul><li>RAID 6 is like RAID 5 but stores two sets of parity, allowing survival of two simultaneous drive failures.</li><li>Requires at least four drives.</li><li>More fault tolerant than RAID 5, but has higher write overhead due to extra parity calculations.</li><li>Useful for large arrays where the chance of a second failure during rebuild is a real concern.</li></ul>","images":[]},{"content":"<h2>Removable Storage Drives</h2><ul><li>Drive enclosures can turn internal drives (HDD/SSD) into external USB storage.</li><li>Great for backups, data transfer, or repurposing old drives.</li><li>External drives can be HDD or SSD; SSD external drives are faster and more shock-resistant.</li><li>Memory cards (SD, microSD) are common in mobile devices and cameras, and also by speed ratings (important for cameras/video).</li></ul>","images":[]},{"content":"<h2>Optical Drives</h2><ul><li>Optical drives read/write removable discs (CD/DVD/Blu-ray).</li><li>Less common now, but still used for legacy media, software installs, and archival storage.</li><li>Speed and capacity vary: CD (~700MB), DVD (~4.7GB single-layer), Blu-ray (25GB+).</li><li>They often use SATA internally or USB externally.</li></ul>","images":[]},{"content":"<h2>Lesson 3.3 System Memory</h2>","images":[]},{"content":"<h2>System Memory (RAM) Basics</h2><ul><li>RAM is volatile memory: it stores data temporarily while the system is powered on.</li><li>More RAM improves multitasking and helps systems handle larger workloads without relying on slower storage.</li><li>Key specs: capacity (GB), speed (MHz/MT/s), latency (CAS), and form factor (DIMM/SO-DIMM).</li><li>Compatibility depends on the motherboard and CPU platform (DDR generation, supported speeds, channels).</li></ul>","images":[]},{"content":"<h2>DDR Generations</h2><ul><li>DDR generations are not interchangeable (DDR3 vs DDR4 vs DDR5 use different slots/keys).</li><li>Newer DDR typically offers higher speeds and better efficiency.</li><li>Motherboard and CPU must both support the DDR type you install.</li><li>Always check the motherboard QVL/support list for best compatibility.</li></ul>","images":[]},{"content":"<h2>Dual-Channel vs Single-Channel</h2><ul><li>Dual-channel memory uses matched sticks to increase memory bandwidth.</li><li>Installing RAM in the correct paired slots (per motherboard manual) enables dual-channel mode.</li><li>Single-channel works but can reduce performance, especially for integrated graphics systems.</li><li>Matched kits are recommended for stability and best performance.</li></ul>","images":[]},{"content":"<h2>ECC vs Non-ECC</h2><ul><li>ECC (Error-Correcting Code) RAM can detect and correct certain memory errors, improving reliability.</li><li>Common in servers/workstations where stability and uptime matter.</li><li>Requires motherboard and CPU support; not typical for standard consumer desktops.</li><li>Non-ECC is most common for everyday PCs and gaming systems.</li></ul>","images":[]},{"content":"<h2>Lesson 3.4 CPUs</h2>","images":[]},{"content":"<h2>CPU Basics</h2><ul><li>The CPU executes instructions and is a primary driver of system performance.</li><li>Key factors: cores/threads, clock speed, cache, architecture, and power/thermal design (TDP).</li><li>Cooling and proper thermal paste are critical for stability and preventing throttling.</li><li>CPU choice must match motherboard socket and chipset support.</li></ul>","images":[]},{"content":"<h2>CPU Cores and Threads</h2><ul><li>More cores help with parallel workloads (multitasking, content creation, virtualization).</li><li>Threads (via SMT/Hyper-Threading) allow a core to handle multiple instruction streams more efficiently.</li><li>Single-core performance still matters for many everyday tasks and some games.</li><li>Real-world performance depends on workload type, not just core count.</li></ul>","images":[]},{"content":"<h2>CPU Sockets</h2><ul><li>CPU socket type must match the motherboard (Intel and AMD use different families and generations).</li><li>Even within a socket family, chipset/BIOS support can determine which CPUs are compatible.</li><li>Upgrading a CPU may require a BIOS/UEFI update first.</li><li>Never force a CPU into a socket—pin damage is expensive and often irreversible.</li></ul>","images":[]},{"content":"<h2>CPU Cooling and Installation</h2><ul><li>Proper installation includes aligning the CPU correctly, securing it, and applying appropriate thermal compound.</li><li>Attach the heat sink/fan or AIO cooler securely and connect the fan header (CPU_FAN).</li><li>Verify temperatures in BIOS/UEFI and under load to ensure cooling is adequate.</li><li>Improper cooling can cause crashes, throttling, and shortened component lifespan.</li></ul>","images":[]},{"content":"<h2>CPU Types and Motherboard Compatibility</h2><ul><li>Compatibility is primarily about socket, chipset, and BIOS support.</li><li>Feature support like PCIe version, memory type (DDR4/DDR5), and integrated graphics/AI support can matter too.</li><li>Consider core count, thermal requirements, and intended workload when selecting a CPU.</li></ul>","images":[]}];

  // Slide state
  let index = 0;

  // Carousel state (for current slide)
  let imgIndex = 0;

  // Audio state
  let audioEnabled = false;

  // ---- Audio resolution (supports many filename styles) ----
  const AUDIO_FOLDERS = ["audio", "../audio"]; // tries System-Devices/audio first, then repo-root audio
  const AUDIO_BASES = (n) => [pad2(n), String(n), `slide-${pad2(n)}`, `slide-${n}`];
  const AUDIO_EXTS = ["mp3", "m4a", "wav", "ogg"];

  const audioSrcCache = new Map(); // slideNumber (1-based) -> resolved src string

  async function urlExists(url) {
    try {
      const head = await fetch(url, { method: "HEAD", cache: "no-store" });
      if (head.ok) return true;

      // Some hosts don’t like HEAD; try tiny ranged GET
      const get = await fetch(url, {
        method: "GET",
        headers: { "Range": "bytes=0-0" },
        cache: "no-store"
      });
      return get.ok;
    } catch (e) {
      return false;
    }
  }

  async function resolveAudioSrc(slideNumber) {
    if (audioSrcCache.has(slideNumber)) return audioSrcCache.get(slideNumber);

    const candidates = [];
    for (const folder of AUDIO_FOLDERS) {
      for (const base of AUDIO_BASES(slideNumber)) {
        for (const ext of AUDIO_EXTS) {
          candidates.push(`${folder}/${base}.${ext}`);
          candidates.push(`${folder}/${base}.${ext.toUpperCase()}`);
        }
      }
    }

    for (const c of candidates) {
      if (await urlExists(c)) {
        audioSrcCache.set(slideNumber, c);
        return c;
      }
    }

    console.log(`[audio] No audio file found for slide ${slideNumber}. Tried:`, candidates);
    return null;
  }

  async function playCurrentAudio() {
    if (!audioEnabled) return;

    const audio = document.getElementById("slideAudio");
    audio.pause();
    audio.currentTime = 0;

    // Optional per-slide override:
    // slides[i].audio = "audio/customname.mp3"  OR  slides[i].audio = false to disable
    let src = slides[index].audio;
    if (src === false) return;

    if (typeof src !== "string" || !src.trim()) {
      src = await resolveAudioSrc(index + 1);
    }
    if (!src) return;

    const abs = new URL(src, window.location.href).href;
    if (audio.src !== abs) {
      audio.src = src;
      audio.load();
    }

    try {
      await audio.play();
    } catch (err) {
      console.log("[audio] Play blocked or missing file:", err);
    }
  }

  function enableAudio() {
    audioEnabled = true;
    document.getElementById("replayBtn").disabled = false;
    playCurrentAudio();
  }

  function replayAudio() {
    playCurrentAudio();
  }

  // ---- Carousel ----
  function renderCarousel() {
    const wrap = document.getElementById("carouselWrap");
    const imgEl = document.getElementById("carouselImg");
    const dotsEl = document.getElementById("dots");
    const imgCounter = document.getElementById("imgCounter");
    const prevBtn = document.getElementById("prevImgBtn");
    const nextBtn = document.getElementById("nextImgBtn");

    const filenames = (slides[index].images || []).filter(Boolean);

    if (filenames.length === 0) {
      wrap.style.display = "none";
      return;
    }

    wrap.style.display = "block";

    if (imgIndex < 0) imgIndex = 0;
    if (imgIndex > filenames.length - 1) imgIndex = filenames.length - 1;

    imgEl.src = `images/${filenames[imgIndex]}`;
    imgCounter.textContent = `Image ${imgIndex + 1} / ${filenames.length}`;

    prevBtn.disabled = (filenames.length <= 1) || (imgIndex === 0);
    nextBtn.disabled = (filenames.length <= 1) || (imgIndex === filenames.length - 1);

    dotsEl.innerHTML = "";
    if (filenames.length > 1) {
      filenames.forEach((_, i) => {
        const b = document.createElement("button");
        b.className = "cDot" + (i === imgIndex ? " active" : "");
        b.title = `Go to image ${i + 1}`;
        b.onclick = () => { imgIndex = i; renderCarousel(); };
        dotsEl.appendChild(b);
      });
    }
  }

  function nextImage() {
    const filenames = (slides[index].images || []).filter(Boolean);
    if (imgIndex < filenames.length - 1) {
      imgIndex++;
      renderCarousel();
    }
  }

  function prevImage() {
    if (imgIndex > 0) {
      imgIndex--;
      renderCarousel();
    }
  }

  // ---- Slides ----
  function updateCounters() {
    const t = `Slide ${index + 1} / ${slides.length}`;
    document.getElementById("counter").textContent = t;
    document.getElementById("counterInline").textContent = `${index + 1} / ${slides.length}`;
  }

  function showSlide() {
    document.getElementById("slide").innerHTML = slides[index].content;
    updateCounters();

    imgIndex = 0;
    renderCarousel();

    playCurrentAudio();
  }

  function nextSlide() {
    if (index < slides.length - 1) index++;
    showSlide();
  }

  function prevSlide() {
    if (index > 0) index--;
    showSlide();
  }

  function goToFirstSlide() {
    index = 0;
    showSlide();
  }

  function goHome() {
    window.location.href = "../";
  }

  // Keyboard:
  // Left/Right = slide nav
  // A/D = image nav
  // Home = first slide
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowRight") nextSlide();
    if (e.key === "ArrowLeft") prevSlide();
    if (e.key.toLowerCase() === "d") nextImage();
    if (e.key.toLowerCase() === "a") prevImage();
    if (e.key === "Home") goToFirstSlide();
  });

  showSlide();
</script>

</body>
</html>
